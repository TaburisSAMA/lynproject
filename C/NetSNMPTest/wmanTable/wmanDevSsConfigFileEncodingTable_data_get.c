/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.20 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "wmanDevSsConfigFileEncodingTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement wmanDevSsConfigFileEncodingTable get routines.
 * TODO:240:M: Implement wmanDevSsConfigFileEncodingTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanDevSsConfigFileEncodingTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingTable is subid 1 of wmanDevSsObjects.
 * Its status is Current.
 * OID: .1.0.8802.16.1.1.2.1, length: 8
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement wmanDevSsConfigFileEncodingTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
wmanDevSsConfigFileEncodingTable_indexes_set_tbl_idx
    (wmanDevSsConfigFileEncodingTable_mib_index * tbl_idx,
     long wmanDevSsDeviceIndex_val)
{
    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsConfigFileEncodingTable_indexes_set_tbl_idx", "called\n"));

    /*
     * wmanDevSsDeviceIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/a/w/e/R/d/h 
     */
    tbl_idx->wmanDevSsDeviceIndex = wmanDevSsDeviceIndex_val;


    return MFD_SUCCESS;
}                               /* wmanDevSsConfigFileEncodingTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
wmanDevSsConfigFileEncodingTable_indexes_set
    (wmanDevSsConfigFileEncodingTable_rowreq_ctx * rowreq_ctx,
     long wmanDevSsDeviceIndex_val)
{
    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsConfigFileEncodingTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        wmanDevSsConfigFileEncodingTable_indexes_set_tbl_idx(&rowreq_ctx->
                                                             tbl_idx,
                                                             wmanDevSsDeviceIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 !=
        wmanDevSsConfigFileEncodingTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                      &rowreq_ctx->
                                                      tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* wmanDevSsConfigFileEncodingTable_indexes_set */


/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsMicConfigSetting
 * wmanDevSsMicConfigSetting is subid 2 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.2
 * Description:
The value field contains the SS MIC code. This is used
            to detect unauthorized modification or corruption of
            the configuration file.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  20;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 20)
 */
/**
 * Extract the current value of the wmanDevSsMicConfigSetting data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsMicConfigSetting_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsMicConfigSetting_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsMicConfigSetting.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsMicConfigSetting_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsMicConfigSetting_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsMicConfigSetting_get(wmanDevSsConfigFileEncodingTable_rowreq_ctx *
                              rowreq_ctx,
                              char **wmanDevSsMicConfigSetting_val_ptr_ptr,
                              size_t
                              *wmanDevSsMicConfigSetting_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsMicConfigSetting_val_ptr_ptr)
                   && (NULL != *wmanDevSsMicConfigSetting_val_ptr_ptr));
    netsnmp_assert(NULL != wmanDevSsMicConfigSetting_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsMicConfigSetting_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanDevSsMicConfigSetting data.
     * copy (* wmanDevSsMicConfigSetting_val_ptr_ptr ) data and (* wmanDevSsMicConfigSetting_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanDevSsMicConfigSetting data
     */
    if ((NULL == (*wmanDevSsMicConfigSetting_val_ptr_ptr)) ||
        ((*wmanDevSsMicConfigSetting_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanDevSsMicConfigSetting_len *
          sizeof(rowreq_ctx->data.wmanDevSsMicConfigSetting[0])))) {
        /*
         * allocate space for wmanDevSsMicConfigSetting data
         */
        (*wmanDevSsMicConfigSetting_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanDevSsMicConfigSetting_len *
                   sizeof(rowreq_ctx->data.wmanDevSsMicConfigSetting[0]));
        if (NULL == (*wmanDevSsMicConfigSetting_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanDevSsMicConfigSetting_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanDevSsMicConfigSetting_len *
        sizeof(rowreq_ctx->data.wmanDevSsMicConfigSetting[0]);
    memcpy((*wmanDevSsMicConfigSetting_val_ptr_ptr),
           rowreq_ctx->data.wmanDevSsMicConfigSetting,
           rowreq_ctx->data.wmanDevSsMicConfigSetting_len *
           sizeof(rowreq_ctx->data.wmanDevSsMicConfigSetting[0]));

    return MFD_SUCCESS;
}                               /* wmanDevSsMicConfigSetting_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsVendorId
 * wmanDevSsVendorId is subid 3 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.3
 * Description:
This value identifies the managed SS vendor to which the
            software upgrade is to be applied.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  3;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 3)
 */
/**
 * Extract the current value of the wmanDevSsVendorId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsVendorId_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsVendorId_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsVendorId.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsVendorId_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsVendorId_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsVendorId_get(wmanDevSsConfigFileEncodingTable_rowreq_ctx *
                      rowreq_ctx, char **wmanDevSsVendorId_val_ptr_ptr,
                      size_t *wmanDevSsVendorId_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsVendorId_val_ptr_ptr)
                   && (NULL != *wmanDevSsVendorId_val_ptr_ptr));
    netsnmp_assert(NULL != wmanDevSsVendorId_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsVendorId_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanDevSsVendorId data.
     * copy (* wmanDevSsVendorId_val_ptr_ptr ) data and (* wmanDevSsVendorId_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanDevSsVendorId data
     */
    if ((NULL == (*wmanDevSsVendorId_val_ptr_ptr)) ||
        ((*wmanDevSsVendorId_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanDevSsVendorId_len *
          sizeof(rowreq_ctx->data.wmanDevSsVendorId[0])))) {
        /*
         * allocate space for wmanDevSsVendorId data
         */
        (*wmanDevSsVendorId_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanDevSsVendorId_len *
                   sizeof(rowreq_ctx->data.wmanDevSsVendorId[0]));
        if (NULL == (*wmanDevSsVendorId_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanDevSsVendorId_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanDevSsVendorId_len *
        sizeof(rowreq_ctx->data.wmanDevSsVendorId[0]);
    memcpy((*wmanDevSsVendorId_val_ptr_ptr),
           rowreq_ctx->data.wmanDevSsVendorId,
           rowreq_ctx->data.wmanDevSsVendorId_len *
           sizeof(rowreq_ctx->data.wmanDevSsVendorId[0]));

    return MFD_SUCCESS;
}                               /* wmanDevSsVendorId_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsHwId
 * wmanDevSsHwId is subid 4 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.4
 * Description:
This value identifies the hardware version to which the
            software upgrade is to be applied.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the wmanDevSsHwId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsHwId_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsHwId_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsHwId.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsHwId_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsHwId_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsHwId_get(wmanDevSsConfigFileEncodingTable_rowreq_ctx * rowreq_ctx,
                  char **wmanDevSsHwId_val_ptr_ptr,
                  size_t *wmanDevSsHwId_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsHwId_val_ptr_ptr)
                   && (NULL != *wmanDevSsHwId_val_ptr_ptr));
    netsnmp_assert(NULL != wmanDevSsHwId_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsHwId_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanDevSsHwId data.
     * copy (* wmanDevSsHwId_val_ptr_ptr ) data and (* wmanDevSsHwId_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanDevSsHwId data
     */
    if ((NULL == (*wmanDevSsHwId_val_ptr_ptr)) ||
        ((*wmanDevSsHwId_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanDevSsHwId_len *
          sizeof(rowreq_ctx->data.wmanDevSsHwId[0])))) {
        /*
         * allocate space for wmanDevSsHwId data
         */
        (*wmanDevSsHwId_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanDevSsHwId_len *
                   sizeof(rowreq_ctx->data.wmanDevSsHwId[0]));
        if (NULL == (*wmanDevSsHwId_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanDevSsHwId_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanDevSsHwId_len *
        sizeof(rowreq_ctx->data.wmanDevSsHwId[0]);
    memcpy((*wmanDevSsHwId_val_ptr_ptr), rowreq_ctx->data.wmanDevSsHwId,
           rowreq_ctx->data.wmanDevSsHwId_len *
           sizeof(rowreq_ctx->data.wmanDevSsHwId[0]));

    return MFD_SUCCESS;
}                               /* wmanDevSsHwId_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsSwVersion
 * wmanDevSsSwVersion is subid 5 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.5
 * Description:
This value identifies the software version of the software
             upgrade file. The value is administered by the vendor
             identifed in the Vendor ID field. It should be defined by
             the vendor to be unique with respect to a given hardware
             ID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the wmanDevSsSwVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsSwVersion_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsSwVersion_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsSwVersion.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsSwVersion_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsSwVersion_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsSwVersion_get(wmanDevSsConfigFileEncodingTable_rowreq_ctx *
                       rowreq_ctx, char **wmanDevSsSwVersion_val_ptr_ptr,
                       size_t *wmanDevSsSwVersion_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsSwVersion_val_ptr_ptr)
                   && (NULL != *wmanDevSsSwVersion_val_ptr_ptr));
    netsnmp_assert(NULL != wmanDevSsSwVersion_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsSwVersion_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanDevSsSwVersion data.
     * copy (* wmanDevSsSwVersion_val_ptr_ptr ) data and (* wmanDevSsSwVersion_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanDevSsSwVersion data
     */
    if ((NULL == (*wmanDevSsSwVersion_val_ptr_ptr)) ||
        ((*wmanDevSsSwVersion_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanDevSsSwVersion_len *
          sizeof(rowreq_ctx->data.wmanDevSsSwVersion[0])))) {
        /*
         * allocate space for wmanDevSsSwVersion data
         */
        (*wmanDevSsSwVersion_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanDevSsSwVersion_len *
                   sizeof(rowreq_ctx->data.wmanDevSsSwVersion[0]));
        if (NULL == (*wmanDevSsSwVersion_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanDevSsSwVersion_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanDevSsSwVersion_len *
        sizeof(rowreq_ctx->data.wmanDevSsSwVersion[0]);
    memcpy((*wmanDevSsSwVersion_val_ptr_ptr),
           rowreq_ctx->data.wmanDevSsSwVersion,
           rowreq_ctx->data.wmanDevSsSwVersion_len *
           sizeof(rowreq_ctx->data.wmanDevSsSwVersion[0]));

    return MFD_SUCCESS;
}                               /* wmanDevSsSwVersion_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsUpgradeFileName
 * wmanDevSsUpgradeFileName is subid 6 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.6
 * Description:
The filename is a fully qualified directory path
            name which is in a format appropriate to the server.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the wmanDevSsUpgradeFileName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsUpgradeFileName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsUpgradeFileName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsUpgradeFileName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsUpgradeFileName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsUpgradeFileName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsUpgradeFileName_get(wmanDevSsConfigFileEncodingTable_rowreq_ctx *
                             rowreq_ctx,
                             char **wmanDevSsUpgradeFileName_val_ptr_ptr,
                             size_t
                             *wmanDevSsUpgradeFileName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsUpgradeFileName_val_ptr_ptr)
                   && (NULL != *wmanDevSsUpgradeFileName_val_ptr_ptr));
    netsnmp_assert(NULL != wmanDevSsUpgradeFileName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanDevSsConfigFileEncodingTable:wmanDevSsUpgradeFileName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanDevSsUpgradeFileName data.
     * copy (* wmanDevSsUpgradeFileName_val_ptr_ptr ) data and (* wmanDevSsUpgradeFileName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanDevSsUpgradeFileName data
     */
    if ((NULL == (*wmanDevSsUpgradeFileName_val_ptr_ptr)) ||
        ((*wmanDevSsUpgradeFileName_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanDevSsUpgradeFileName_len *
          sizeof(rowreq_ctx->data.wmanDevSsUpgradeFileName[0])))) {
        /*
         * allocate space for wmanDevSsUpgradeFileName data
         */
        (*wmanDevSsUpgradeFileName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanDevSsUpgradeFileName_len *
                   sizeof(rowreq_ctx->data.wmanDevSsUpgradeFileName[0]));
        if (NULL == (*wmanDevSsUpgradeFileName_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanDevSsUpgradeFileName_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanDevSsUpgradeFileName_len *
        sizeof(rowreq_ctx->data.wmanDevSsUpgradeFileName[0]);
    memcpy((*wmanDevSsUpgradeFileName_val_ptr_ptr),
           rowreq_ctx->data.wmanDevSsUpgradeFileName,
           rowreq_ctx->data.wmanDevSsUpgradeFileName_len *
           sizeof(rowreq_ctx->data.wmanDevSsUpgradeFileName[0]));

    return MFD_SUCCESS;
}                               /* wmanDevSsUpgradeFileName_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsSwUpgradeTftpServer
 * wmanDevSsSwUpgradeTftpServer is subid 7 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.7
 * Description:
This object is the IP address of the TFTP server on
            which the software upgrade file for the SS resides.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the wmanDevSsSwUpgradeTftpServer data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsSwUpgradeTftpServer_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsSwUpgradeTftpServer_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsSwUpgradeTftpServer.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsSwUpgradeTftpServer_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsSwUpgradeTftpServer_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsSwUpgradeTftpServer_get
    (wmanDevSsConfigFileEncodingTable_rowreq_ctx * rowreq_ctx,
     char **wmanDevSsSwUpgradeTftpServer_val_ptr_ptr,
     size_t *wmanDevSsSwUpgradeTftpServer_val_ptr_len_ptr)
{
    /*
     * TODO:231:M: |-> copy wmanDevSsSwUpgradeTftpServer data.
     * TODO:231:M: |   |-> get address type from your context pointer.
     */
    int             addressType = -1;
    size_t          actual_size = 0;

    return MFD_SKIP;            /* TODO:235:M: |-> Remove SKIP once you've set wmanDevSsSwUpgradeTftpServer data */

    switch (addressType) {
    case INETADDRESSTYPE_UNKNOWN:
        /*
         * An unknown address type. This value MUST  be used if the value
         * of the InetAddress object is a zero-length string. It may also be
         * used to indicate an IP address which is not in one of the formats
         * defined below.
         */
        actual_size = rowreq_ctx->data.wmanDevSsSwUpgradeTftpServer_len;
        break;

    case INETADDRESSTYPE_IPV4:
        /*
         * Represents an IPv4 network address:
         *      octets   contents         encoding
         *       1-4     IPv4 address     network-byte order
         */
        actual_size = 4;
        break;

    case INETADDRESSTYPE_IPV6:
        /*
         * Represents an IPv6 network address:
         *
         *      octets   contents         encoding
         *       1-16    IPv6 address     network-byte order
         */
        actual_size = 16;
        break;

    case INETADDRESSTYPE_IPV4Z:
        /*
         * Represents a non-global IPv4 network address together
         *    with its zone index:
         *
         *      octets   contents         encoding
         *       1-4     IPv4 address     network-byte order
         *       5-8     zone index       network-byte order
         */
        actual_size = 8;
        break;

    case INETADDRESSTYPE_IPV6Z:
        /*
         * Represents a non-global IPv6 network address together
         *    with its zone index:
         *
         *      octets   contents         encoding
         *       1-16    IPv6 address     network-byte order
         *      17-20    zone index       network-byte order
         */
        actual_size = 20;
        break;

    case INETADDRESSTYPE_DNS:
        /*
         * Represents a DNS domain name. The name SHOULD be fully
         *    qualified whenever possible.
         */
        actual_size = rowreq_ctx->data.wmanDevSsSwUpgradeTftpServer_len;
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown InetAddressType %d for wmanDevSsSwUpgradeTftpServer\n",
                 addressType);
        return SNMP_ERR_GENERR;
    }

    if (actual_size > (*wmanDevSsSwUpgradeTftpServer_val_ptr_len_ptr)) {
        snmp_log(LOG_ERR,
                 "actual size %d too big for wmanDevSsSwUpgradeTftpServer\n",
                 addressType);
        return SNMP_ERR_GENERR;
    }

    memcpy((*wmanDevSsSwUpgradeTftpServer_val_ptr_ptr),
           rowreq_ctx->data.wmanDevSsSwUpgradeTftpServer, actual_size);
    (*wmanDevSsSwUpgradeTftpServer_val_ptr_len_ptr) = actual_size;

    return MFD_SUCCESS;
}                               /* wmanDevSsSwUpgradeTftpServer_get */

/*---------------------------------------------------------------------
 * WMAN-DEV-MIB::wmanDevSsConfigFileEncodingEntry.wmanDevSsTftpServerTimeStamp
 * wmanDevSsTftpServerTimeStamp is subid 8 of wmanDevSsConfigFileEncodingEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.0.8802.16.1.1.2.1.1.8
 * Description:
This is the sending time of the configuration file in
            seconds. The definition of time is as in IETF RFC 868.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 2d-1d-1d,1d:1d:1d.1d,1a1d:1d
 *
 * Ranges:  8, 11;
 *
 * Its syntax is DateAndTime (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 11)
 */
/**
 * Extract the current value of the wmanDevSsTftpServerTimeStamp data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanDevSsTftpServerTimeStamp_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanDevSsTftpServerTimeStamp.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanDevSsTftpServerTimeStamp_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanDevSsTftpServerTimeStamp_get
    (wmanDevSsConfigFileEncodingTable_rowreq_ctx * rowreq_ctx,
     char **wmanDevSsTftpServerTimeStamp_val_ptr_ptr,
     size_t *wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr)
{
    /*
     * temporary storage for date. If you have any of this data available
     * directly, use it instead. 
     */
    int             year, month, day, hour, minutes, seconds, deci_seconds;
    int             rc, utc_offset_direction, utc_offset_hours,
        utc_offset_minutes;

   /** we should have a pointer and enough storage */
    netsnmp_assert((NULL != wmanDevSsTftpServerTimeStamp_val_ptr_ptr)
                   && (NULL != *wmanDevSsTftpServerTimeStamp_val_ptr_ptr));
    netsnmp_assert((NULL != wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr)
                   && ((*wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr) >=
                       11));

    /*
     * TODO:231:o: |-> copy wmanDevSsTftpServerTimeStamp data.
     * get the date from your context pointer.
     */
    return MFD_SKIP;            /* TODO:234:M: |-> Remove SKIP once you've set wmanDevSsTftpServerTimeStamp data */

    year = 0;                   /* 0..65536 */
    month = 0;                  /* 1..12 */
    day = 0;                    /* 1..31 */
    hour = 0;                   /* 0..23 */
    minutes = 0;                /* 0..59 */
    seconds = 0;                /* 0..60 (60 indicates a leap-second) */
    deci_seconds = 0;           /* 0..9 */

    /*
     * setting utc offset is optional. Leave the values as is if you
     * want to exclude this information. 
     */
    utc_offset_direction = 0;   /* -1, +1 */
    utc_offset_hours = -1;      /* 0..13 */
    utc_offset_minutes = -1;    /* 0..59 */

    /*
     * call convenience function to set data 
     */
    rc = netsnmp_dateandtime_set_buf_from_vars
        (*wmanDevSsTftpServerTimeStamp_val_ptr_ptr,
         wmanDevSsTftpServerTimeStamp_val_ptr_len_ptr, year, month, day,
         hour, minutes, seconds, deci_seconds, utc_offset_direction,
         utc_offset_hours, utc_offset_minutes);
    if (rc != SNMP_ERR_NOERROR)
        return rc;


    return MFD_SUCCESS;
}                               /* wmanDevSsTftpServerTimeStamp_get */



/** @} */
