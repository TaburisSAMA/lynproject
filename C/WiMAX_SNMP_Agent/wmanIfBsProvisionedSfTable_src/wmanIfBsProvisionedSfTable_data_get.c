/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "wmanIfBsProvisionedSfTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement wmanIfBsProvisionedSfTable get routines.
 * TODO:240:M: Implement wmanIfBsProvisionedSfTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanIfBsProvisionedSfTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-IF-MIB::wmanIfBsProvisionedSfTable is subid 1 of wmanIfBsPacketCs.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement wmanIfBsProvisionedSfTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param ifIndex_val
 * @param wmanIfBsSfId_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
wmanIfBsProvisionedSfTable_indexes_set_tbl_idx
    (wmanIfBsProvisionedSfTable_mib_index * tbl_idx, long ifIndex_val,
     u_long wmanIfBsSfId_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_indexes_set_tbl_idx", "called\n"));

    /*
     * ifIndex(1)/InterfaceIndex/ASN_INTEGER/long(long)//l/A/w/e/R/d/H 
     */
    tbl_idx->ifIndex = ifIndex_val;

    /*
     * wmanIfBsSfId(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/h 
     */
    tbl_idx->wmanIfBsSfId = wmanIfBsSfId_val;


    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
wmanIfBsProvisionedSfTable_indexes_set
    (wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx, long ifIndex_val,
     u_long wmanIfBsSfId_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        wmanIfBsProvisionedSfTable_indexes_set_tbl_idx(&rowreq_ctx->
                                                       tbl_idx,
                                                       ifIndex_val,
                                                       wmanIfBsSfId_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != wmanIfBsProvisionedSfTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                     &rowreq_ctx->
                                                     tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfTable_indexes_set */


/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfDirection
 * wmanIfBsSfDirection is subid 2 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.2
 * Description:
An attribute indicating the service flow is downstream or
             upstream.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  downstream(1), upstream(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSfDirection data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfDirection_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSfDirection_get(wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx,
                        u_long * wmanIfBsSfDirection_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSfDirection_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfDirection_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSfDirection data.
     * copy (* wmanIfBsSfDirection_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSfDirection_val_ptr) = rowreq_ctx->data.wmanIfBsSfDirection;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfDirection_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsServiceClassIndex
 * wmanIfBsServiceClassIndex is subid 3 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.3
 * Description:
The index in wmanIfBsServiceClassTable describing the
             service class or QoS parameters for such service flow.
             If no associated entry in wmanIfBsServiceClassTable
             exists, this object returns a value of zero.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsServiceClassIndex data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsServiceClassIndex_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsServiceClassIndex_get(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              long *wmanIfBsServiceClassIndex_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsServiceClassIndex_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsServiceClassIndex_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsServiceClassIndex data.
     * copy (* wmanIfBsServiceClassIndex_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsServiceClassIndex_val_ptr) =
        rowreq_ctx->data.wmanIfBsServiceClassIndex;

    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassIndex_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfState
 * wmanIfBsSfState is subid 4 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.4
 * Description:
wmanIfBsSfState determines the requested state of a service
             flow. 
             - authorized state: A service flow is provisioned but
               not resource is reserved yet
             - admitted state: service flow has resources reserved.
             - active state: has resources committed by the BS (e.g., is
               actively sending maps containing unsolicited grants for a
               UGS-based service flow),
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  authorized(1), admitted(2), active(3)
 *
 * Its syntax is WmanIfSfState (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSfState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfState_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSfState_get(wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx,
                    u_long * wmanIfBsSfState_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSfState_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfState_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSfState data.
     * copy (* wmanIfBsSfState_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSfState_val_ptr) = rowreq_ctx->data.wmanIfBsSfState;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfState_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfProvisionedTime
 * wmanIfBsSfProvisionedTime is subid 5 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.5
 * Description:
Indicates the date and time when the service flow is
             provisioned.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSfProvisionedTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfProvisionedTime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSfProvisionedTime_get(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long * wmanIfBsSfProvisionedTime_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSfProvisionedTime_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfProvisionedTime_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSfProvisionedTime data.
     * copy (* wmanIfBsSfProvisionedTime_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSfProvisionedTime_val_ptr) =
        rowreq_ctx->data.wmanIfBsSfProvisionedTime;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfProvisionedTime_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfCsSpecification
 * wmanIfBsSfCsSpecification is subid 6 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.6
 * Description:
This parameter specifies the convergence sublayer
             encapsulation mode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 7/16. Values:  noCs(0), packetIpV4(1), packetIpV6(2), packet802dot3Ethernet(3), packet802dot1QVlan(4), packetIpV4Over802dot3(5), packetIpV6Over802dot3(6), packetIpV4Over802dot1Q(7), packetIpV6Over802dot1Q(8), atm(9)
 *
 * Its syntax is WmanIfCsSpecification (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSfCsSpecification data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfCsSpecification_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSfCsSpecification_get(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long * wmanIfBsSfCsSpecification_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSfCsSpecification_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfCsSpecification_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSfCsSpecification data.
     * copy (* wmanIfBsSfCsSpecification_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSfCsSpecification_val_ptr) =
        rowreq_ctx->data.wmanIfBsSfCsSpecification;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfCsSpecification_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsProvisionedSfRowStatus
 * wmanIfBsProvisionedSfRowStatus is subid 7 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.7
 * Description:
This object is used to create a new row or modify or
             delete an existing row in this table.

             If the implementator of this MIB has choosen not
             to implement 'dynamic assignment' of profiles, this
             object is not useful and should return noSuchName
             upon SNMP request.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsProvisionedSfRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsProvisionedSfRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsProvisionedSfRowStatus_get(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   wmanIfBsProvisionedSfRowStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsProvisionedSfRowStatus_val_ptr);

    (*wmanIfBsProvisionedSfRowStatus_val_ptr) =
        rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus;

    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfRowStatus_get */



/** @} */
