/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/*
 * standard Net-SNMP includes
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header
 */
#include "wmanIfBsProvisionedSfTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanIfBsProvisionedSfTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-IF-MIB::wmanIfBsProvisionedSfTable is subid 1 of wmanIfBsPacketCs.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1, length: 12
 */
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * wmanIfBsProvisionedSfTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * wmanIfBsProvisionedSfTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wmanIfBsProvisionedSfTable_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx
                                      * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_undo_setup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:451:M: |-> Setup wmanIfBsProvisionedSfTable undo.
     * set up wmanIfBsProvisionedSfTable undo information, in preparation for a set.
     * Undo storage is in (* wmanIfBsProvisionedSfRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsProvisionedSfTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wmanIfBsProvisionedSfTable_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_undo", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:451:M: |-> wmanIfBsProvisionedSfTable undo.
     * wmanIfBsProvisionedSfTable undo information, in response to a failed set.
     * Undo storage is in (* wmanIfBsProvisionedSfRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsProvisionedSfTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsProvisionedSfTable_undo_cleanup
    (wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_undo_cleanup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:452:M: |-> Cleanup wmanIfBsProvisionedSfTable undo.
     * Undo storage is in (* wmanIfBsProvisionedSfRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsProvisionedSfTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wmanIfBsProvisionedSfTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wmanIfBsProvisionedSfTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsProvisionedSfTable_commit(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                  rowreq_ctx)
{
    int             rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit wmanIfBsProvisionedSfTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WMANIFBSSFDIRECTION_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSSFDIRECTION_FLAG; /* clear wmanIfBsSfDirection */
        /*
         * TODO:482:o: |-> commit column wmanIfBsSfDirection.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsSfDirection commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsSfDirection
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSSFDIRECTION_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSSERVICECLASSINDEX_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSSERVICECLASSINDEX_FLAG;   /* clear wmanIfBsServiceClassIndex */
        /*
         * TODO:482:o: |-> commit column wmanIfBsServiceClassIndex.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsServiceClassIndex commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsServiceClassIndex
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSSERVICECLASSINDEX_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSSFSTATE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSSFSTATE_FLAG;     /* clear wmanIfBsSfState */
        /*
         * TODO:482:o: |-> commit column wmanIfBsSfState.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsSfState commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsSfState
             */
            rowreq_ctx->column_set_flags |= COLUMN_WMANIFBSSFSTATE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSSFPROVISIONEDTIME_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSSFPROVISIONEDTIME_FLAG;   /* clear wmanIfBsSfProvisionedTime */
        /*
         * TODO:482:o: |-> commit column wmanIfBsSfProvisionedTime.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsSfProvisionedTime commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsSfProvisionedTime
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSSFPROVISIONEDTIME_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSSFCSSPECIFICATION_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSSFCSSPECIFICATION_FLAG;   /* clear wmanIfBsSfCsSpecification */
        /*
         * TODO:482:o: |-> commit column wmanIfBsSfCsSpecification.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsSfCsSpecification commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsSfCsSpecification
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSSFCSSPECIFICATION_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSPROVISIONEDSFROWSTATUS_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSPROVISIONEDSFROWSTATUS_FLAG;      /* clear wmanIfBsProvisionedSfRowStatus */
        /*
         * TODO:482:o: |-> commit column wmanIfBsProvisionedSfRowStatus.
         */
        //rc = -1;
        rc = MFD_SUCCESS;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsProvisionedSfTable column wmanIfBsProvisionedSfRowStatus commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsProvisionedSfRowStatus
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSPROVISIONEDSFROWSTATUS_FLAG;
        }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
        snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n",
                 save_flags);
        return MFD_ERROR;
    }

    return rc;
}                               /* wmanIfBsProvisionedSfTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wmanIfBsProvisionedSfTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wmanIfBsProvisionedSfTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsProvisionedSfTable_undo_commit
    (wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfTable_undo_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:485:M: |-> Undo wmanIfBsProvisionedSfTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */


    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
}                               /* wmanIfBsProvisionedSfTable_undo_commit */

/*
 * TODO:440:M: Implement wmanIfBsProvisionedSfTable node value checks.
 * TODO:450:M: Implement wmanIfBsProvisionedSfTable undo functions.
 * TODO:460:M: Implement wmanIfBsProvisionedSfTable set functions.
 * TODO:480:M: Implement wmanIfBsProvisionedSfTable commit functions.
 */
/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfDirection
 * wmanIfBsSfDirection is subid 2 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.2
 * Description:
An attribute indicating the service flow is downstream or
             upstream.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  downstream(1), upstream(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfDirection_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  downstream(1), upstream(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsSfDirection_check_value(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                rowreq_ctx, u_long wmanIfBsSfDirection_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfDirection_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsSfDirection value.
     */

    return MFD_SUCCESS;         /* wmanIfBsSfDirection value not illegal */
}                               /* wmanIfBsSfDirection_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsSfDirection_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx *
                               rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfDirection_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsSfDirection undo.
     */
    /*
     * copy wmanIfBsSfDirection data
     * set rowreq_ctx->undo->wmanIfBsSfDirection from rowreq_ctx->data.wmanIfBsSfDirection
     */
    rowreq_ctx->undo->wmanIfBsSfDirection =
        rowreq_ctx->data.wmanIfBsSfDirection;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfDirection_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsSfDirection_val
 *        A long containing the new value.
 */
int
wmanIfBsSfDirection_set(wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx,
                        u_long wmanIfBsSfDirection_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfDirection_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsSfDirection value.
     * set wmanIfBsSfDirection value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsSfDirection = wmanIfBsSfDirection_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfDirection_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsSfDirection_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                         rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfDirection_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsSfDirection undo.
     */
    /*
     * copy wmanIfBsSfDirection data
     * set rowreq_ctx->data.wmanIfBsSfDirection from rowreq_ctx->undo->wmanIfBsSfDirection
     */
    rowreq_ctx->data.wmanIfBsSfDirection =
        rowreq_ctx->undo->wmanIfBsSfDirection;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfDirection_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsServiceClassIndex
 * wmanIfBsServiceClassIndex is subid 3 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.3
 * Description:
The index in wmanIfBsServiceClassTable describing the
             service class or QoS parameters for such service flow.
             If no associated entry in wmanIfBsServiceClassTable
             exists, this object returns a value of zero.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsServiceClassIndex_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsServiceClassIndex_check_value(wmanIfBsProvisionedSfTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long wmanIfBsServiceClassIndex_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsServiceClassIndex_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsServiceClassIndex value.
     */

    return MFD_SUCCESS;         /* wmanIfBsServiceClassIndex value not illegal */
}                               /* wmanIfBsServiceClassIndex_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsServiceClassIndex_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx
                                     * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsServiceClassIndex_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsServiceClassIndex undo.
     */
    /*
     * copy wmanIfBsServiceClassIndex data
     * set rowreq_ctx->undo->wmanIfBsServiceClassIndex from rowreq_ctx->data.wmanIfBsServiceClassIndex
     */
    rowreq_ctx->undo->wmanIfBsServiceClassIndex =
        rowreq_ctx->data.wmanIfBsServiceClassIndex;


    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassIndex_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsServiceClassIndex_val
 *        A long containing the new value.
 */
int
wmanIfBsServiceClassIndex_set(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              long wmanIfBsServiceClassIndex_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsServiceClassIndex_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsServiceClassIndex value.
     * set wmanIfBsServiceClassIndex value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsServiceClassIndex =
        wmanIfBsServiceClassIndex_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassIndex_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsServiceClassIndex_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                               rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsServiceClassIndex_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsServiceClassIndex undo.
     */
    /*
     * copy wmanIfBsServiceClassIndex data
     * set rowreq_ctx->data.wmanIfBsServiceClassIndex from rowreq_ctx->undo->wmanIfBsServiceClassIndex
     */
    rowreq_ctx->data.wmanIfBsServiceClassIndex =
        rowreq_ctx->undo->wmanIfBsServiceClassIndex;


    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassIndex_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfState
 * wmanIfBsSfState is subid 4 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.4
 * Description:
wmanIfBsSfState determines the requested state of a service
             flow.
             - authorized state: A service flow is provisioned but
               not resource is reserved yet
             - admitted state: service flow has resources reserved.
             - active state: has resources committed by the BS (e.g., is
               actively sending maps containing unsolicited grants for a
               UGS-based service flow),
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  authorized(1), admitted(2), active(3)
 *
 * Its syntax is WmanIfSfState (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfState_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  authorized(1), admitted(2), active(3)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsSfState_check_value(wmanIfBsProvisionedSfTable_rowreq_ctx *
                            rowreq_ctx, u_long wmanIfBsSfState_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfState_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsSfState value.
     */

    return MFD_SUCCESS;         /* wmanIfBsSfState value not illegal */
}                               /* wmanIfBsSfState_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsSfState_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx *
                           rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfState_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsSfState undo.
     */
    /*
     * copy wmanIfBsSfState data
     * set rowreq_ctx->undo->wmanIfBsSfState from rowreq_ctx->data.wmanIfBsSfState
     */
    rowreq_ctx->undo->wmanIfBsSfState = rowreq_ctx->data.wmanIfBsSfState;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfState_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsSfState_val
 *        A long containing the new value.
 */
int
wmanIfBsSfState_set(wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx,
                    u_long wmanIfBsSfState_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfState_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsSfState value.
     * set wmanIfBsSfState value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsSfState = wmanIfBsSfState_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfState_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsSfState_undo(wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfState_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsSfState undo.
     */
    /*
     * copy wmanIfBsSfState data
     * set rowreq_ctx->data.wmanIfBsSfState from rowreq_ctx->undo->wmanIfBsSfState
     */
    rowreq_ctx->data.wmanIfBsSfState = rowreq_ctx->undo->wmanIfBsSfState;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfState_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfProvisionedTime
 * wmanIfBsSfProvisionedTime is subid 5 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.5
 * Description:
Indicates the date and time when the service flow is
             provisioned.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfProvisionedTime_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_TIMETICKS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsSfProvisionedTime_check_value(wmanIfBsProvisionedSfTable_rowreq_ctx
                                      * rowreq_ctx,
                                      u_long wmanIfBsSfProvisionedTime_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfProvisionedTime_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsSfProvisionedTime value.
     */

    return MFD_SUCCESS;         /* wmanIfBsSfProvisionedTime value not illegal */
}                               /* wmanIfBsSfProvisionedTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsSfProvisionedTime_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx
                                     * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfProvisionedTime_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsSfProvisionedTime undo.
     */
    /*
     * copy wmanIfBsSfProvisionedTime data
     * set rowreq_ctx->undo->wmanIfBsSfProvisionedTime from rowreq_ctx->data.wmanIfBsSfProvisionedTime
     */
    rowreq_ctx->undo->wmanIfBsSfProvisionedTime =
        rowreq_ctx->data.wmanIfBsSfProvisionedTime;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfProvisionedTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsSfProvisionedTime_val
 *        A u_long containing the new value.
 */
int
wmanIfBsSfProvisionedTime_set(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long wmanIfBsSfProvisionedTime_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfProvisionedTime_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsSfProvisionedTime value.
     * set wmanIfBsSfProvisionedTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsSfProvisionedTime =
        wmanIfBsSfProvisionedTime_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfProvisionedTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsSfProvisionedTime_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                               rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfProvisionedTime_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsSfProvisionedTime undo.
     */
    /*
     * copy wmanIfBsSfProvisionedTime data
     * set rowreq_ctx->data.wmanIfBsSfProvisionedTime from rowreq_ctx->undo->wmanIfBsSfProvisionedTime
     */
    rowreq_ctx->data.wmanIfBsSfProvisionedTime =
        rowreq_ctx->undo->wmanIfBsSfProvisionedTime;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfProvisionedTime_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsSfCsSpecification
 * wmanIfBsSfCsSpecification is subid 6 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.6
 * Description:
This parameter specifies the convergence sublayer
             encapsulation mode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 7/16. Values:  noCs(0), packetIpV4(1), packetIpV6(2), packet802dot3Ethernet(3), packet802dot1QVlan(4), packetIpV4Over802dot3(5), packetIpV6Over802dot3(6), packetIpV4Over802dot1Q(7), packetIpV6Over802dot1Q(8), atm(9)
 *
 * Its syntax is WmanIfCsSpecification (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSfCsSpecification_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  noCs(0), packetIpV4(1), packetIpV6(2), packet802dot3Ethernet(3), packet802dot1QVlan(4), packetIpV4Over802dot3(5), packetIpV6Over802dot3(6), packetIpV4Over802dot1Q(7), packetIpV6Over802dot1Q(8), atm(9)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsSfCsSpecification_check_value(wmanIfBsProvisionedSfTable_rowreq_ctx
                                      * rowreq_ctx,
                                      u_long wmanIfBsSfCsSpecification_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfCsSpecification_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsSfCsSpecification value.
     */

    return MFD_SUCCESS;         /* wmanIfBsSfCsSpecification value not illegal */
}                               /* wmanIfBsSfCsSpecification_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsSfCsSpecification_undo_setup(wmanIfBsProvisionedSfTable_rowreq_ctx
                                     * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfCsSpecification_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsSfCsSpecification undo.
     */
    /*
     * copy wmanIfBsSfCsSpecification data
     * set rowreq_ctx->undo->wmanIfBsSfCsSpecification from rowreq_ctx->data.wmanIfBsSfCsSpecification
     */
    rowreq_ctx->undo->wmanIfBsSfCsSpecification =
        rowreq_ctx->data.wmanIfBsSfCsSpecification;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfCsSpecification_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsSfCsSpecification_val
 *        A long containing the new value.
 */
int
wmanIfBsSfCsSpecification_set(wmanIfBsProvisionedSfTable_rowreq_ctx *
                              rowreq_ctx,
                              u_long wmanIfBsSfCsSpecification_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfCsSpecification_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsSfCsSpecification value.
     * set wmanIfBsSfCsSpecification value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsSfCsSpecification =
        wmanIfBsSfCsSpecification_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsSfCsSpecification_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsSfCsSpecification_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                               rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsSfCsSpecification_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsSfCsSpecification undo.
     */
    /*
     * copy wmanIfBsSfCsSpecification data
     * set rowreq_ctx->data.wmanIfBsSfCsSpecification from rowreq_ctx->undo->wmanIfBsSfCsSpecification
     */
    rowreq_ctx->data.wmanIfBsSfCsSpecification =
        rowreq_ctx->undo->wmanIfBsSfCsSpecification;


    return MFD_SUCCESS;
}                               /* wmanIfBsSfCsSpecification_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsProvisionedSfEntry.wmanIfBsProvisionedSfRowStatus
 * wmanIfBsProvisionedSfRowStatus is subid 7 of wmanIfBsProvisionedSfEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.1.1.7
 * Description:
This object is used to create a new row or modify or
             delete an existing row in this table.

             If the implementator of this MIB has choosen not
             to implement 'dynamic assignment' of profiles, this
             object is not useful and should return noSuchName
             upon SNMP request.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsProvisionedSfRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsProvisionedSfTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsProvisionedSfRowStatus_check_value
    (wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsProvisionedSfRowStatus_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfRowStatus_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsProvisionedSfRowStatus value.
     */

    return MFD_SUCCESS;         /* wmanIfBsProvisionedSfRowStatus value not illegal */
}                               /* wmanIfBsProvisionedSfRowStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsProvisionedSfTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsProvisionedSfTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsProvisionedSfRowStatus_undo_setup
    (wmanIfBsProvisionedSfTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfRowStatus_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsProvisionedSfRowStatus undo.
     */
    /*
     * copy wmanIfBsProvisionedSfRowStatus data
     * set rowreq_ctx->undo->wmanIfBsProvisionedSfRowStatus from rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus
     */
    rowreq_ctx->undo->wmanIfBsProvisionedSfRowStatus =
        rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus;


    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfRowStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsProvisionedSfRowStatus_val
 *        A long containing the new value.
 */
int
wmanIfBsProvisionedSfRowStatus_set(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long
                                   wmanIfBsProvisionedSfRowStatus_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfRowStatus_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsProvisionedSfRowStatus value.
     * set wmanIfBsProvisionedSfRowStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus =
        wmanIfBsProvisionedSfRowStatus_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfRowStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsProvisionedSfRowStatus_undo(wmanIfBsProvisionedSfTable_rowreq_ctx *
                                    rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsProvisionedSfTable:wmanIfBsProvisionedSfRowStatus_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsProvisionedSfRowStatus undo.
     */
    /*
     * copy wmanIfBsProvisionedSfRowStatus data
     * set rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus from rowreq_ctx->undo->wmanIfBsProvisionedSfRowStatus
     */
    rowreq_ctx->data.wmanIfBsProvisionedSfRowStatus =
        rowreq_ctx->undo->wmanIfBsProvisionedSfRowStatus;


    return MFD_SUCCESS;
}                               /* wmanIfBsProvisionedSfRowStatus_undo */

/** @} */
