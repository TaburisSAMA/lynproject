/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "wmanIfBsRegisteredSsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement wmanIfBsRegisteredSsTable get routines.
 * TODO:240:M: Implement wmanIfBsRegisteredSsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanIfBsRegisteredSsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-IF-MIB::wmanIfBsRegisteredSsTable is subid 1 of wmanIfBsCps.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement wmanIfBsRegisteredSsTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param ifIndex_val
 * @param wmanIfBsSsMacAddress_ptr
 * @param wmanIfBsSsMacAddress_ptr_len
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
wmanIfBsRegisteredSsTable_indexes_set_tbl_idx
    (wmanIfBsRegisteredSsTable_mib_index * tbl_idx, long ifIndex_val,
     char *wmanIfBsSsMacAddress_val_ptr,
     size_t wmanIfBsSsMacAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsRegisteredSsTable_indexes_set_tbl_idx", "called\n"));

    /*
     * ifIndex(1)/InterfaceIndex/ASN_INTEGER/long(long)//l/A/w/e/R/d/H 
     */
    tbl_idx->ifIndex = ifIndex_val;

    /*
     * wmanIfBsSsMacAddress(1)/MacAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/H 
     */
    tbl_idx->wmanIfBsSsMacAddress_len = sizeof(tbl_idx->wmanIfBsSsMacAddress) / sizeof(tbl_idx->wmanIfBsSsMacAddress[0]);       /* max length */
    /*
     * make sure there is enough space for wmanIfBsSsMacAddress data
     */
    if ((NULL == tbl_idx->wmanIfBsSsMacAddress) ||
        (tbl_idx->wmanIfBsSsMacAddress_len <
         (wmanIfBsSsMacAddress_val_ptr_len))) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wmanIfBsSsMacAddress_len = wmanIfBsSsMacAddress_val_ptr_len;
    memcpy(tbl_idx->wmanIfBsSsMacAddress, wmanIfBsSsMacAddress_val_ptr,
           wmanIfBsSsMacAddress_val_ptr_len *
           sizeof(wmanIfBsSsMacAddress_val_ptr[0]));


    return MFD_SUCCESS;
}                               /* wmanIfBsRegisteredSsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
wmanIfBsRegisteredSsTable_indexes_set(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx, long ifIndex_val,
                                      char *wmanIfBsSsMacAddress_val_ptr,
                                      size_t
                                      wmanIfBsSsMacAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsRegisteredSsTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        wmanIfBsRegisteredSsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                      ifIndex_val,
                                                      wmanIfBsSsMacAddress_val_ptr,
                                                      wmanIfBsSsMacAddress_val_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != wmanIfBsRegisteredSsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                    &rowreq_ctx->
                                                    tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* wmanIfBsRegisteredSsTable_indexes_set */


/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsBasicCid
 * wmanIfBsSsBasicCid is subid 2 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.2
 * Description:
The value of this object indicates the SS's basic CID
             that was sent in the RNG-RSP message.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is WmanIfCidType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsBasicCid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsBasicCid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsBasicCid_get(wmanIfBsRegisteredSsTable_rowreq_ctx * rowreq_ctx,
                       long *wmanIfBsSsBasicCid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsBasicCid_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsBasicCid_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsBasicCid data.
     * copy (* wmanIfBsSsBasicCid_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsBasicCid_val_ptr) = rowreq_ctx->data.wmanIfBsSsBasicCid;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsBasicCid_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsPrimaryCid
 * wmanIfBsSsPrimaryCid is subid 3 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.3
 * Description:
The value of this object indicates the primary CID of the
             SS received from the RNG-RSP message.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is WmanIfCidType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsPrimaryCid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsPrimaryCid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsPrimaryCid_get(wmanIfBsRegisteredSsTable_rowreq_ctx * rowreq_ctx,
                         long *wmanIfBsSsPrimaryCid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsPrimaryCid_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsPrimaryCid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsPrimaryCid data.
     * copy (* wmanIfBsSsPrimaryCid_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsPrimaryCid_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsPrimaryCid;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsPrimaryCid_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsSecondaryCid
 * wmanIfBsSsSecondaryCid is subid 4 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.4
 * Description:
The value of this object indicates the secondary
             management CID present in the REG-RSP message. The value
             should be null if the 2nd management channel is not
             available.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is WmanIfCidType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsSecondaryCid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsSecondaryCid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsSecondaryCid_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                           rowreq_ctx,
                           long *wmanIfBsSsSecondaryCid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsSecondaryCid_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsSecondaryCid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsSecondaryCid data.
     * copy (* wmanIfBsSsSecondaryCid_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsSecondaryCid_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsSecondaryCid;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsSecondaryCid_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsManagementSupport
 * wmanIfBsSsManagementSupport is subid 5 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.5
 * Description:
This object indicates whether or not the SS is managed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  unmanagedSs(0), managedSs(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSsManagementSupport data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsManagementSupport_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsManagementSupport_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long *
                                wmanIfBsSsManagementSupport_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsManagementSupport_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsManagementSupport_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsManagementSupport data.
     * copy (* wmanIfBsSsManagementSupport_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsManagementSupport_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsManagementSupport;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsManagementSupport_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsIpManagementMode
 * wmanIfBsSsIpManagementMode is subid 6 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.6
 * Description:
The IP management mode parameter dictates whether
             the provider intends to manage the SS on an ongoing
             basis via IP-based mechanisms.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  unmanaged(0), ipManaged(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSsIpManagementMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsIpManagementMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsIpManagementMode_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * wmanIfBsSsIpManagementMode_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsIpManagementMode_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsIpManagementMode_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsIpManagementMode data.
     * copy (* wmanIfBsSsIpManagementMode_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsIpManagementMode_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsIpManagementMode;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsIpManagementMode_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqEnable
 * wmanIfBsSs2ndMgmtArqEnable is subid 7 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.7
 * Description:
True(1) ARQ enabling is requested for the 2nd
             management channel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqEnable_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * wmanIfBsSs2ndMgmtArqEnable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqEnable_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqEnable_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqEnable data.
     * copy (* wmanIfBsSs2ndMgmtArqEnable_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqEnable_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqEnable;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqEnable_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqWindowSize
 * wmanIfBsSs2ndMgmtArqWindowSize is subid 8 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.8
 * Description:
Indicates the maximum number of unacknowledged 
             fragments at any time for 2nd management channel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 1024;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqWindowSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqWindowSize_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqWindowSize_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                                   rowreq_ctx,
                                   long
                                   *wmanIfBsSs2ndMgmtArqWindowSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqWindowSize_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqWindowSize_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqWindowSize data.
     * copy (* wmanIfBsSs2ndMgmtArqWindowSize_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqWindowSize_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqWindowSize;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqWindowSize_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqDnLinkTxDelay
 * wmanIfBsSs2ndMgmtArqDnLinkTxDelay is subid 9 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.9
 * Description:
The object defines the ARQ transmitter delay for
             downlink transmission.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqDnLinkTxDelay data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqDnLinkTxDelay_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqDnLinkTxDelay_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long
                                      *wmanIfBsSs2ndMgmtArqDnLinkTxDelay_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqDnLinkTxDelay_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqDnLinkTxDelay_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqDnLinkTxDelay data.
     * copy (* wmanIfBsSs2ndMgmtArqDnLinkTxDelay_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqDnLinkTxDelay_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqDnLinkTxDelay;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqDnLinkTxDelay_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqUpLinkTxDelay
 * wmanIfBsSs2ndMgmtArqUpLinkTxDelay is subid 10 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.10
 * Description:
The object defines the ARQ transmitter delay for
             uplink transmission.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqUpLinkTxDelay data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqUpLinkTxDelay_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqUpLinkTxDelay_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long
                                      *wmanIfBsSs2ndMgmtArqUpLinkTxDelay_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqUpLinkTxDelay_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqUpLinkTxDelay_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqUpLinkTxDelay data.
     * copy (* wmanIfBsSs2ndMgmtArqUpLinkTxDelay_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqUpLinkTxDelay_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqUpLinkTxDelay;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqUpLinkTxDelay_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqDnLinkRxDelay
 * wmanIfBsSs2ndMgmtArqDnLinkRxDelay is subid 11 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.11
 * Description:
The object defines the ARQ receiver delay for
             downlink transmission.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqDnLinkRxDelay data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqDnLinkRxDelay_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqDnLinkRxDelay_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long
                                      *wmanIfBsSs2ndMgmtArqDnLinkRxDelay_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqDnLinkRxDelay_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqDnLinkRxDelay_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqDnLinkRxDelay data.
     * copy (* wmanIfBsSs2ndMgmtArqDnLinkRxDelay_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqDnLinkRxDelay_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqDnLinkRxDelay;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqDnLinkRxDelay_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqUpLinkRxDelay
 * wmanIfBsSs2ndMgmtArqUpLinkRxDelay is subid 12 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.12
 * Description:
The object defines the ARQ receiver delay for
             uplink transmission.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqUpLinkRxDelay data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqUpLinkRxDelay_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqUpLinkRxDelay_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long
                                      *wmanIfBsSs2ndMgmtArqUpLinkRxDelay_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqUpLinkRxDelay_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqUpLinkRxDelay_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqUpLinkRxDelay data.
     * copy (* wmanIfBsSs2ndMgmtArqUpLinkRxDelay_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqUpLinkRxDelay_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqUpLinkRxDelay;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqUpLinkRxDelay_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqBlockLifetime
 * wmanIfBsSs2ndMgmtArqBlockLifetime is subid 13 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.13
 * Description:
The maximum time interval an ARQ fragment will be
             managed by the transmitter ARQ machine, once
             initial transmission of the fragment has occured.
             If transmission or retransmission of the fragment
             is not acknowledged by the receiver before the 
             time limit is reached, the fragment is discarded.
             A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqBlockLifetime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqBlockLifetime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqBlockLifetime_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long
                                      *wmanIfBsSs2ndMgmtArqBlockLifetime_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqBlockLifetime_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqBlockLifetime_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqBlockLifetime data.
     * copy (* wmanIfBsSs2ndMgmtArqBlockLifetime_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqBlockLifetime_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqBlockLifetime;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqBlockLifetime_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqSyncLossTimeout
 * wmanIfBsSs2ndMgmtArqSyncLossTimeout is subid 14 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.14
 * Description:
The maximum interval before declaring a loss
             of synchronization of the sender and receiver
             state machines. A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqSyncLossTimeout data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqSyncLossTimeout_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqSyncLossTimeout_get
    (wmanIfBsRegisteredSsTable_rowreq_ctx * rowreq_ctx,
     long *wmanIfBsSs2ndMgmtArqSyncLossTimeout_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqSyncLossTimeout_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqSyncLossTimeout_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqSyncLossTimeout data.
     * copy (* wmanIfBsSs2ndMgmtArqSyncLossTimeout_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqSyncLossTimeout_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqSyncLossTimeout;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqSyncLossTimeout_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqDeliverInOrder
 * wmanIfBsSs2ndMgmtArqDeliverInOrder is subid 15 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.15
 * Description:
Indicates whether or not data is to be delivered
             by the receiving MAC to its client application
             in the order in which data was handed off to the
             originating MAC.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqDeliverInOrder data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqDeliverInOrder_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqDeliverInOrder_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                       * rowreq_ctx,
                                       u_long *
                                       wmanIfBsSs2ndMgmtArqDeliverInOrder_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqDeliverInOrder_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqDeliverInOrder_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqDeliverInOrder data.
     * copy (* wmanIfBsSs2ndMgmtArqDeliverInOrder_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqDeliverInOrder_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqDeliverInOrder;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqDeliverInOrder_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqRxPurgeTimeout
 * wmanIfBsSs2ndMgmtArqRxPurgeTimeout is subid 16 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.16
 * Description:
Indicates the time interval the ARQ window is advanced
             after a fragment is received. A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqRxPurgeTimeout data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqRxPurgeTimeout_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqRxPurgeTimeout_get(wmanIfBsRegisteredSsTable_rowreq_ctx
                                       * rowreq_ctx,
                                       long
                                       *wmanIfBsSs2ndMgmtArqRxPurgeTimeout_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqRxPurgeTimeout_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqRxPurgeTimeout_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqRxPurgeTimeout data.
     * copy (* wmanIfBsSs2ndMgmtArqRxPurgeTimeout_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqRxPurgeTimeout_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqRxPurgeTimeout;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqRxPurgeTimeout_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSs2ndMgmtArqBlockSize
 * wmanIfBsSs2ndMgmtArqBlockSize is subid 17 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.17
 * Description:
This parameter specifies the size of a ARQ block. This
             parameter shall be established by negotiation during the
             connection setup. The requester includes its desired
             setting in the REQ message. The receiver of the REQ
             message shall take the smaller of the value it prefers and
             value in the REQ message. The minimum value is included in
             the RSP message.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 2040;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSs2ndMgmtArqBlockSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSs2ndMgmtArqBlockSize_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSs2ndMgmtArqBlockSize_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                                  rowreq_ctx,
                                  long
                                  *wmanIfBsSs2ndMgmtArqBlockSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSs2ndMgmtArqBlockSize_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSs2ndMgmtArqBlockSize_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSs2ndMgmtArqBlockSize data.
     * copy (* wmanIfBsSs2ndMgmtArqBlockSize_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSs2ndMgmtArqBlockSize_val_ptr) =
        rowreq_ctx->data.wmanIfBsSs2ndMgmtArqBlockSize;

    return MFD_SUCCESS;
}                               /* wmanIfBsSs2ndMgmtArqBlockSize_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsVendorIdEncoding
 * wmanIfBsSsVendorIdEncoding is subid 18 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.18
 * Description:
The value field contains the vendor identification
             specified by the 3 byte vendor-specific organizationally
             unique identifier of the SS or BS MAC address.A vendor ID
             used in a REG-REQ shall be the Vendor ID of the SS sending
             the request. A vendor ID used in a REG-RSP shall be the
             Vendor ID of the BS sending the response.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  3;
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 3)
 */
/**
 * Extract the current value of the wmanIfBsSsVendorIdEncoding data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsVendorIdEncoding_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanIfBsSsVendorIdEncoding.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanIfBsSsVendorIdEncoding_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanIfBsSsVendorIdEncoding_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                               rowreq_ctx,
                               char
                               **wmanIfBsSsVendorIdEncoding_val_ptr_ptr,
                               size_t
                               *wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanIfBsSsVendorIdEncoding_val_ptr_ptr)
                   && (NULL != *wmanIfBsSsVendorIdEncoding_val_ptr_ptr));
    netsnmp_assert(NULL != wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsVendorIdEncoding_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsVendorIdEncoding data.
     * copy (* wmanIfBsSsVendorIdEncoding_val_ptr_ptr ) data and (* wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanIfBsSsVendorIdEncoding data
     */
    if ((NULL == (*wmanIfBsSsVendorIdEncoding_val_ptr_ptr)) ||
        ((*wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanIfBsSsVendorIdEncoding_len *
          sizeof(rowreq_ctx->data.wmanIfBsSsVendorIdEncoding[0])))) {
        /*
         * allocate space for wmanIfBsSsVendorIdEncoding data
         */
        (*wmanIfBsSsVendorIdEncoding_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanIfBsSsVendorIdEncoding_len *
                   sizeof(rowreq_ctx->data.wmanIfBsSsVendorIdEncoding[0]));
        if (NULL == (*wmanIfBsSsVendorIdEncoding_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanIfBsSsVendorIdEncoding_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanIfBsSsVendorIdEncoding_len *
        sizeof(rowreq_ctx->data.wmanIfBsSsVendorIdEncoding[0]);
    memcpy((*wmanIfBsSsVendorIdEncoding_val_ptr_ptr),
           rowreq_ctx->data.wmanIfBsSsVendorIdEncoding,
           rowreq_ctx->data.wmanIfBsSsVendorIdEncoding_len *
           sizeof(rowreq_ctx->data.wmanIfBsSsVendorIdEncoding[0]));

    return MFD_SUCCESS;
}                               /* wmanIfBsSsVendorIdEncoding_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsAasBroadcastPermission
 * wmanIfBsSsAasBroadcastPermission is subid 19 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.19
 * Description:
This parameter specifies if SS can issue contention-based
             bandwidth request or not.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  contBasedBwReqPermitted(0), contBasedBwReqNotPermitted(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSsAasBroadcastPermission data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsAasBroadcastPermission_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsAasBroadcastPermission_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     wmanIfBsSsAasBroadcastPermission_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsAasBroadcastPermission_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsAasBroadcastPermission_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsAasBroadcastPermission data.
     * copy (* wmanIfBsSsAasBroadcastPermission_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsAasBroadcastPermission_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsAasBroadcastPermission;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsAasBroadcastPermission_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsMaxTxPowerBpsk
 * wmanIfBsSsMaxTxPowerBpsk is subid 20 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.20
 * Description:
The maximum available power for BPSK. The maximum power
             parameters are reported in dBm and quantized in 0.5 dBm
             steps ranging from -64 dBm (encoded 0x00) to 63.5 dBm
             (encoded 0xFF). Values outside this range shall be assigned
             the closest extreme. This parameter is only applicable to
             systems supporting the SCa, OFDM or OFDMA PHY.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is WmanIfMaxTxPowerType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsMaxTxPowerBpsk data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsMaxTxPowerBpsk_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsMaxTxPowerBpsk_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                             rowreq_ctx,
                             long *wmanIfBsSsMaxTxPowerBpsk_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsMaxTxPowerBpsk_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsMaxTxPowerBpsk_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsMaxTxPowerBpsk data.
     * copy (* wmanIfBsSsMaxTxPowerBpsk_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsMaxTxPowerBpsk_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsMaxTxPowerBpsk;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsMaxTxPowerBpsk_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsMaxTxPowerQpsk
 * wmanIfBsSsMaxTxPowerQpsk is subid 21 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.21
 * Description:
The maximum available power for QPSK. The maximum power
             parameters are reported in dBm and quantized in 0.5 dBm
             steps ranging from -64 dBm (encoded 0x00) to 63.5 dBm
             (encoded 0xFF). Values outside this range shall be assigned
             to closest extreme. This parameter is only applicable to
             systems supporting the SCa, OFDM or OFDMA PHY.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is WmanIfMaxTxPowerType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsMaxTxPowerQpsk data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsMaxTxPowerQpsk_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsMaxTxPowerQpsk_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                             rowreq_ctx,
                             long *wmanIfBsSsMaxTxPowerQpsk_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsMaxTxPowerQpsk_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsMaxTxPowerQpsk_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsMaxTxPowerQpsk data.
     * copy (* wmanIfBsSsMaxTxPowerQpsk_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsMaxTxPowerQpsk_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsMaxTxPowerQpsk;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsMaxTxPowerQpsk_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsMaxTxPower16Qam
 * wmanIfBsSsMaxTxPower16Qam is subid 22 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.22
 * Description:
The maximum available power for 16-QAM constellations.
             The maximum power parameters are reported in dBm and
             quantized in 0.5 dBm steps ranging from -64 dBm (encoded
             0x00) to 63.5 dBm (encoded 0xFF). Values outside this
             range shall be assigned the closest extreme. This parameter
             is only applicable to systems supporting the SCa, OFDM or
             OFDMA PHY.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is WmanIfMaxTxPowerType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsMaxTxPower16Qam data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsMaxTxPower16Qam_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsMaxTxPower16Qam_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                              rowreq_ctx,
                              long *wmanIfBsSsMaxTxPower16Qam_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsMaxTxPower16Qam_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsMaxTxPower16Qam_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsMaxTxPower16Qam data.
     * copy (* wmanIfBsSsMaxTxPower16Qam_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsMaxTxPower16Qam_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsMaxTxPower16Qam;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsMaxTxPower16Qam_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsMaxTxPower64Qam
 * wmanIfBsSsMaxTxPower64Qam is subid 23 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.23
 * Description:
The maximum available power for 64-QAM constellations.
             The maximum power parameters are reported in dBm and
             quantized in 0.5 dBm steps ranging from -64 dBm (encoded
             0x00) to 63.5 dBm (encoded 0xFF). Values outside this
             range shall be assigned the closest extreme. SSs that do
             not support QAM64 shall report the value of 0x00. This
             parameter is only applicable to systems supporting the SCa,
             OFDM or OFDMA PHY.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is WmanIfMaxTxPowerType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsSsMaxTxPower64Qam data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsMaxTxPower64Qam_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsMaxTxPower64Qam_get(wmanIfBsRegisteredSsTable_rowreq_ctx *
                              rowreq_ctx,
                              long *wmanIfBsSsMaxTxPower64Qam_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsMaxTxPower64Qam_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsMaxTxPower64Qam_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsMaxTxPower64Qam data.
     * copy (* wmanIfBsSsMaxTxPower64Qam_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsMaxTxPower64Qam_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsMaxTxPower64Qam;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsMaxTxPower64Qam_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsRegisteredSsEntry.wmanIfBsSsMacVersion
 * wmanIfBsSsMacVersion is subid 24 of wmanIfBsRegisteredSsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.2.1.10.184.1.1.2.1.1.24
 * Description:
This parameter specifies the version of 802.16 to which the
             message originator conforms.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  ieee802Dot16Of2001(1), ieee802Dot16cOf2002(2), ieee802Dot16aOf2003(3), ieee802Dot16Of2004(4)
 *
 * Its syntax is WmanIfMacVersion (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsSsMacVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsSsMacVersion_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsSsMacVersion_get(wmanIfBsRegisteredSsTable_rowreq_ctx * rowreq_ctx,
                         u_long * wmanIfBsSsMacVersion_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsSsMacVersion_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsRegisteredSsTable:wmanIfBsSsMacVersion_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsSsMacVersion data.
     * copy (* wmanIfBsSsMacVersion_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsSsMacVersion_val_ptr) =
        rowreq_ctx->data.wmanIfBsSsMacVersion;

    return MFD_SUCCESS;
}                               /* wmanIfBsSsMacVersion_get */



/** @} */
