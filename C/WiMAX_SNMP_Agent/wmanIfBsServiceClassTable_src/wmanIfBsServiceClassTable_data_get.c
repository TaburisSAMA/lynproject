/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "wmanIfBsServiceClassTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement wmanIfBsServiceClassTable get routines.
 * TODO:240:M: Implement wmanIfBsServiceClassTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanIfBsServiceClassTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-IF-MIB::wmanIfBsServiceClassTable is subid 3 of wmanIfBsPacketCs.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3, length: 12
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement wmanIfBsServiceClassTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param ifIndex_val
 * @param wmanIfBsQoSProfileIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
wmanIfBsServiceClassTable_indexes_set_tbl_idx
    (wmanIfBsServiceClassTable_mib_index * tbl_idx, long ifIndex_val,
     long wmanIfBsQoSProfileIndex_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_indexes_set_tbl_idx", "called\n"));

    /*
     * ifIndex(1)/InterfaceIndex/ASN_INTEGER/long(long)//l/A/w/e/R/d/H 
     */
    tbl_idx->ifIndex = ifIndex_val;

    /*
     * wmanIfBsQoSProfileIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/a/w/e/R/d/h 
     */
    tbl_idx->wmanIfBsQoSProfileIndex = wmanIfBsQoSProfileIndex_val;


    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
wmanIfBsServiceClassTable_indexes_set(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx, long ifIndex_val,
                                      long wmanIfBsQoSProfileIndex_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        wmanIfBsServiceClassTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                      ifIndex_val,
                                                      wmanIfBsQoSProfileIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != wmanIfBsServiceClassTable_index_to_oid(&rowreq_ctx->oid_idx,
                                                    &rowreq_ctx->
                                                    tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* wmanIfBsServiceClassTable_indexes_set */


/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosServiceClassName
 * wmanIfBsQosServiceClassName is subid 2 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.2
 * Description:
Refers to the Service Class Name
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  2 - 128;
 *
 * Its syntax is WmanIfServClassName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 128)
 */
/**
 * Extract the current value of the wmanIfBsQosServiceClassName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosServiceClassName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wmanIfBsQosServiceClassName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wmanIfBsQosServiceClassName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wmanIfBsQosServiceClassName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wmanIfBsQosServiceClassName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wmanIfBsQosServiceClassName_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                char
                                **wmanIfBsQosServiceClassName_val_ptr_ptr,
                                size_t
                                *wmanIfBsQosServiceClassName_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != wmanIfBsQosServiceClassName_val_ptr_ptr)
                   && (NULL != *wmanIfBsQosServiceClassName_val_ptr_ptr));
    netsnmp_assert(NULL != wmanIfBsQosServiceClassName_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosServiceClassName_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosServiceClassName data.
     * copy (* wmanIfBsQosServiceClassName_val_ptr_ptr ) data and (* wmanIfBsQosServiceClassName_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for wmanIfBsQosServiceClassName data
     */
    if ((NULL == (*wmanIfBsQosServiceClassName_val_ptr_ptr)) ||
        ((*wmanIfBsQosServiceClassName_val_ptr_len_ptr) <
         (rowreq_ctx->data.wmanIfBsQosServiceClassName_len *
          sizeof(rowreq_ctx->data.wmanIfBsQosServiceClassName[0])))) {
        /*
         * allocate space for wmanIfBsQosServiceClassName data
         */
        (*wmanIfBsQosServiceClassName_val_ptr_ptr) =
            malloc(rowreq_ctx->data.wmanIfBsQosServiceClassName_len *
                   sizeof(rowreq_ctx->data.
                          wmanIfBsQosServiceClassName[0]));
        if (NULL == (*wmanIfBsQosServiceClassName_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*wmanIfBsQosServiceClassName_val_ptr_len_ptr) =
        rowreq_ctx->data.wmanIfBsQosServiceClassName_len *
        sizeof(rowreq_ctx->data.wmanIfBsQosServiceClassName[0]);
    memcpy((*wmanIfBsQosServiceClassName_val_ptr_ptr),
           rowreq_ctx->data.wmanIfBsQosServiceClassName,
           rowreq_ctx->data.wmanIfBsQosServiceClassName_len *
           sizeof(rowreq_ctx->data.wmanIfBsQosServiceClassName[0]));

    return MFD_SUCCESS;
}                               /* wmanIfBsQosServiceClassName_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSTrafficPriority
 * wmanIfBsQoSTrafficPriority is subid 3 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.3
 * Description:
The value of this parameter specifies the priority
             assigned to a service flow. For uplink service flows,
             the BS should use this parameter when determining
             precedence in request service and grant generation,
             and the SS shall preferentially select contention
             Request opportunities for Priority Request CIDs
             based on this priority. Higher numbers indicate higher
             priority
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 7;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQoSTrafficPriority data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSTrafficPriority_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSTrafficPriority_get(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               long *wmanIfBsQoSTrafficPriority_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSTrafficPriority_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSTrafficPriority_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSTrafficPriority data.
     * copy (* wmanIfBsQoSTrafficPriority_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSTrafficPriority_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSTrafficPriority;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSTrafficPriority_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxSustainedRate
 * wmanIfBsQoSMaxSustainedRate is subid 4 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.4
 * Description:
This parameter defines the peak information rate
             of the service. The rate is expressed in bits per
             second and pertains to the SDUs at the input to
             the system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSMaxSustainedRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxSustainedRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSMaxSustainedRate_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long *
                                wmanIfBsQoSMaxSustainedRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSMaxSustainedRate_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxSustainedRate_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSMaxSustainedRate data.
     * copy (* wmanIfBsQoSMaxSustainedRate_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSMaxSustainedRate_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxSustainedRate_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxTrafficBurst
 * wmanIfBsQoSMaxTrafficBurst is subid 5 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.5
 * Description:
This parameter defines the maximum burst size that
             must be accommodated for the service.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSMaxTrafficBurst data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxTrafficBurst_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSMaxTrafficBurst_get(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * wmanIfBsQoSMaxTrafficBurst_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSMaxTrafficBurst_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxTrafficBurst_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSMaxTrafficBurst data.
     * copy (* wmanIfBsQoSMaxTrafficBurst_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSMaxTrafficBurst_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxTrafficBurst_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMinReservedRate
 * wmanIfBsQoSMinReservedRate is subid 6 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.6
 * Description:
This parameter specifies the minimum rate reserved
             for this service flow.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSMinReservedRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMinReservedRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSMinReservedRate_get(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * wmanIfBsQoSMinReservedRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSMinReservedRate_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMinReservedRate_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSMinReservedRate data.
     * copy (* wmanIfBsQoSMinReservedRate_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSMinReservedRate_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSMinReservedRate;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMinReservedRate_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSToleratedJitter
 * wmanIfBsQoSToleratedJitter is subid 7 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.7
 * Description:
This parameter defines the Maximum delay 
             variation (jitter) for the connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSToleratedJitter data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSToleratedJitter_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSToleratedJitter_get(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long * wmanIfBsQoSToleratedJitter_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSToleratedJitter_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSToleratedJitter_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSToleratedJitter data.
     * copy (* wmanIfBsQoSToleratedJitter_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSToleratedJitter_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSToleratedJitter;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSToleratedJitter_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxLatency
 * wmanIfBsQoSMaxLatency is subid 8 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.8
 * Description:
The value of this parameter specifies the maximum
             latency between the reception of a packet by the BS
             or SS on its network interface and the forwarding
             of the packet to its RF Interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSMaxLatency data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxLatency_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSMaxLatency_get(wmanIfBsServiceClassTable_rowreq_ctx *
                          rowreq_ctx,
                          u_long * wmanIfBsQoSMaxLatency_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSMaxLatency_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxLatency_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSMaxLatency data.
     * copy (* wmanIfBsQoSMaxLatency_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSMaxLatency_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSMaxLatency;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxLatency_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSFixedVsVariableSduInd
 * wmanIfBsQoSFixedVsVariableSduInd is subid 9 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.9
 * Description:
The value of this parameter specifies whether the SDUs
             on the service flow are variable-length (0) or 
             fixed-length (1). The parameter is used only if
             packing is on for the service flow. The default value
             is 0, i.e.,variable-length SDUs.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: variableLength
 *
 * Enum range: 2/8. Values:  variableLength(0), fixedLength(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSFixedVsVariableSduInd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSFixedVsVariableSduInd_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSFixedVsVariableSduInd_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     wmanIfBsQoSFixedVsVariableSduInd_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSFixedVsVariableSduInd_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSFixedVsVariableSduInd_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSFixedVsVariableSduInd data.
     * copy (* wmanIfBsQoSFixedVsVariableSduInd_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSFixedVsVariableSduInd_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSFixedVsVariableSduInd_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSSduSize
 * wmanIfBsQoSSduSize is subid 10 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.10
 * Description:
The value of this parameter specifies the length of the
             SDU for a fixed-length SDU service flow. This parameter
             is used only if packing is on and the service flow is
             indicated as carrying fixed-length SDUs. The default
             value is 49 bytes, i.e., VC-switched ATM cells with PHS.
             The parameter is relevant for both ATM and Packet
             Convergence Sublayers.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 49
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSSduSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSSduSize_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSSduSize_get(wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
                       u_long * wmanIfBsQoSSduSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSSduSize_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSSduSize_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSSduSize data.
     * copy (* wmanIfBsQoSSduSize_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQoSSduSize_val_ptr) = rowreq_ctx->data.wmanIfBsQoSSduSize;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSSduSize_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScSchedulingType
 * wmanIfBsQosScSchedulingType is subid 11 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.11
 * Description:
Specifies the upstream scheduling service used for
             upstream service flow. If the referenced parameter
             is not present in the corresponding 802.16 QOS
             Parameter Set of an upstream service flow, the
             default value of this object is bestEffort(2).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: bestEffort
 *
 * Enum range: 3/8. Values:  undefined(1), bestEffort(2), nonRealTimePollingService(3), realTimePollingService(4), reserved(5), unsolicitedGrantService(6)
 *
 * Its syntax is WmanIfSfSchedulingType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQosScSchedulingType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScSchedulingType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScSchedulingType_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long *
                                wmanIfBsQosScSchedulingType_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScSchedulingType_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScSchedulingType_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScSchedulingType data.
     * copy (* wmanIfBsQosScSchedulingType_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScSchedulingType_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScSchedulingType;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScSchedulingType_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqEnable
 * wmanIfBsQosScArqEnable is subid 12 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.12
 * Description:
True(1) ARQ enabling is requested for the connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqEnable_get(wmanIfBsServiceClassTable_rowreq_ctx *
                           rowreq_ctx,
                           u_long * wmanIfBsQosScArqEnable_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqEnable_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqEnable_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqEnable data.
     * copy (* wmanIfBsQosScArqEnable_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqEnable_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqEnable;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqEnable_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqWindowSize
 * wmanIfBsQosScArqWindowSize is subid 13 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.13
 * Description:
Indicates the maximum number of unacknowledged 
             fragments at any time.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 1024;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqWindowSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqWindowSize_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqWindowSize_get(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               long *wmanIfBsQosScArqWindowSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqWindowSize_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqWindowSize_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqWindowSize data.
     * copy (* wmanIfBsQosScArqWindowSize_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqWindowSize_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqWindowSize;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqWindowSize_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqBlockLifetime
 * wmanIfBsQosScArqBlockLifetime is subid 14 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.14
 * Description:
The maximum time interval an ARQ fragment will be
             managed by the transmitter ARQ machine, once
             initial transmission of the fragment has occured.
             If transmission or retransmission of the fragment
             is not acknowledged by the receiver before the 
             time limit is reached, the fragment is discarded.
             A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqBlockLifetime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqBlockLifetime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqBlockLifetime_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                  rowreq_ctx,
                                  long
                                  *wmanIfBsQosScArqBlockLifetime_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqBlockLifetime_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockLifetime_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqBlockLifetime data.
     * copy (* wmanIfBsQosScArqBlockLifetime_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqBlockLifetime_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockLifetime_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqSyncLossTimeout
 * wmanIfBsQosScArqSyncLossTimeout is subid 15 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.15
 * Description:
The maximum interval before declaring a loss
             of synchronization of the sender and receiver
             state machines. A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqSyncLossTimeout data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqSyncLossTimeout_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqSyncLossTimeout_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                    rowreq_ctx,
                                    long
                                    *wmanIfBsQosScArqSyncLossTimeout_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqSyncLossTimeout_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqSyncLossTimeout_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqSyncLossTimeout data.
     * copy (* wmanIfBsQosScArqSyncLossTimeout_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqSyncLossTimeout_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqSyncLossTimeout_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqDeliverInOrder
 * wmanIfBsQosScArqDeliverInOrder is subid 16 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.16
 * Description:
Indicates whether or not data is to be delivered
             by the receiving MAC to its client application
             in the order in which data was handed off to the
             originating MAC.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqDeliverInOrder data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqDeliverInOrder_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqDeliverInOrder_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   wmanIfBsQosScArqDeliverInOrder_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqDeliverInOrder_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqDeliverInOrder_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqDeliverInOrder data.
     * copy (* wmanIfBsQosScArqDeliverInOrder_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqDeliverInOrder_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqDeliverInOrder_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqRxPurgeTimeout
 * wmanIfBsQosScArqRxPurgeTimeout is subid 17 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.17
 * Description:
Indicates the time interval the ARQ window is advanced
             after a fragment is received. A value of 0 means
             Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqRxPurgeTimeout data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqRxPurgeTimeout_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqRxPurgeTimeout_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   long
                                   *wmanIfBsQosScArqRxPurgeTimeout_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqRxPurgeTimeout_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqRxPurgeTimeout_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqRxPurgeTimeout data.
     * copy (* wmanIfBsQosScArqRxPurgeTimeout_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqRxPurgeTimeout_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqRxPurgeTimeout_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqBlockSize
 * wmanIfBsQosScArqBlockSize is subid 18 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.18
 * Description:
The value of this parameter specifies the size of an
             ARQ block. This parameter shall be established by
             negotiation during the connection creation dialog.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 2040;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wmanIfBsQosScArqBlockSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqBlockSize_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosScArqBlockSize_get(wmanIfBsServiceClassTable_rowreq_ctx *
                              rowreq_ctx,
                              long *wmanIfBsQosScArqBlockSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosScArqBlockSize_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockSize_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosScArqBlockSize data.
     * copy (* wmanIfBsQosScArqBlockSize_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosScArqBlockSize_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosScArqBlockSize;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockSize_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosSCMinRsvdTolerableRate
 * wmanIfBsQosSCMinRsvdTolerableRate is subid 19 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.19
 * Description:
Minimum Tolerable Traffic Rate = R (bits/sec) with
             time base T(sec) means the following. Let S denote
             additional demand accumulated at the MAC SAP of the
             transmitter during an arbitrary time interval of the
             length T. Then the amount of data forwarded at the
             receiver to CS (in bits) during this interval should
             be not less than min {S, R * T}.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQosSCMinRsvdTolerableRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosSCMinRsvdTolerableRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQosSCMinRsvdTolerableRate_get(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx,
                                      u_long *
                                      wmanIfBsQosSCMinRsvdTolerableRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQosSCMinRsvdTolerableRate_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosSCMinRsvdTolerableRate_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQosSCMinRsvdTolerableRate data.
     * copy (* wmanIfBsQosSCMinRsvdTolerableRate_val_ptr ) from rowreq_ctx->data
     */
    (*wmanIfBsQosSCMinRsvdTolerableRate_val_ptr) =
        rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosSCMinRsvdTolerableRate_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSReqTxPolicy
 * wmanIfBsQoSReqTxPolicy is subid 20 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.20
 * Description:
The value of this parameter provides the capability to
             specify certain attributes for the associated service
             flow. An attribute is enabled by setting the
             corresponding bit position to 1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 6/16. Values:  noBroadcastBwReq(0), reserved1(1), noPiggybackReq(2), noFragmentData(3), noPHS(4), noSduPacking(5), noCrc(6), reserved2(7)
 *
 * Its syntax is BITS (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Extract the current value of the wmanIfBsQoSReqTxPolicy data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSReqTxPolicy_val_ptr
 *        Pointer to storage for a char variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSReqTxPolicy_get(wmanIfBsServiceClassTable_rowreq_ctx *
                           rowreq_ctx,
                           u_long * wmanIfBsQoSReqTxPolicy_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSReqTxPolicy_val_ptr);


    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSReqTxPolicy_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wmanIfBsQoSReqTxPolicy data.
     * copy (* wmanIfBsQoSReqTxPolicy_val_ptr ) from rowreq_ctx->data
     */
    return MFD_SKIP;
    /*
     * TODO:242:o: update or replace BITS tests (get).
     * If wmanIfBsQoSReqTxPolicy data is stored in SNMP BIT order, individual
     * bit tests are redundant, and you can do a straight copy. If not, then
     * update each if condition to test the correct bit.
     *
     * NOTE WELL: setting bit '0' for:
     *             C  0x0000001
     *          SNMP  0x8000000
     *
     * assuming generated code keeps wmanIfBsQoSReqTxPolicy BITS in SNMP order.
     */
    (*wmanIfBsQoSReqTxPolicy_val_ptr) = @m2c_ctx_rh;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSReqTxPolicy_get */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSServiceClassRowStatus
 * wmanIfBsQoSServiceClassRowStatus is subid 21 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.21
 * Description:
This object is used to create a new row or modify or
             delete an existing row in this table.

             If the implementator of this MIB has choosen not
             to implement 'dynamic assignment' of profiles, this
             object is not useful and should return noSuchName
             upon SNMP request.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the wmanIfBsQoSServiceClassRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSServiceClassRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wmanIfBsQoSServiceClassRowStatus_get(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long *
                                     wmanIfBsQoSServiceClassRowStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wmanIfBsQoSServiceClassRowStatus_val_ptr);

    (*wmanIfBsQoSServiceClassRowStatus_val_ptr) =
        rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSServiceClassRowStatus_get */



/** @} */
