/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "wmanIfBsServiceClassTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table wmanIfBsServiceClassTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WMAN-IF-MIB::wmanIfBsServiceClassTable is subid 3 of wmanIfBsPacketCs.
 * Its status is Current.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3, length: 12
 */
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * wmanIfBsServiceClassTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * wmanIfBsServiceClassTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wmanIfBsServiceClassTable_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_undo_setup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:451:M: |-> Setup wmanIfBsServiceClassTable undo.
     * set up wmanIfBsServiceClassTable undo information, in preparation for a set.
     * Undo storage is in (* wmanIfBsQoSServiceClassRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsServiceClassTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
wmanIfBsServiceClassTable_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_undo", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:451:M: |-> wmanIfBsServiceClassTable undo.
     * wmanIfBsServiceClassTable undo information, in response to a failed set.
     * Undo storage is in (* wmanIfBsQoSServiceClassRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsServiceClassTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsServiceClassTable_undo_cleanup(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_undo_cleanup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:452:M: |-> Cleanup wmanIfBsServiceClassTable undo.
     * Undo storage is in (* wmanIfBsQoSServiceClassRowStatus_val_ptr )*
     */

    return rc;
}                               /* wmanIfBsServiceClassTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wmanIfBsServiceClassTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wmanIfBsServiceClassTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsServiceClassTable_commit(wmanIfBsServiceClassTable_rowreq_ctx *
                                 rowreq_ctx)
{
    int             rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit wmanIfBsServiceClassTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WMANIFBSQOSSERVICECLASSNAME_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSERVICECLASSNAME_FLAG; /* clear wmanIfBsQosServiceClassName */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosServiceClassName.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosServiceClassName commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosServiceClassName
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSERVICECLASSNAME_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSTRAFFICPRIORITY_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSTRAFFICPRIORITY_FLAG;  /* clear wmanIfBsQoSTrafficPriority */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSTrafficPriority.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSTrafficPriority commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSTrafficPriority
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSTRAFFICPRIORITY_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSMAXSUSTAINEDRATE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSMAXSUSTAINEDRATE_FLAG; /* clear wmanIfBsQoSMaxSustainedRate */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSMaxSustainedRate.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSMaxSustainedRate commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSMaxSustainedRate
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSMAXSUSTAINEDRATE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSMAXTRAFFICBURST_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSMAXTRAFFICBURST_FLAG;  /* clear wmanIfBsQoSMaxTrafficBurst */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSMaxTrafficBurst.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSMaxTrafficBurst commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSMaxTrafficBurst
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSMAXTRAFFICBURST_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSMINRESERVEDRATE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSMINRESERVEDRATE_FLAG;  /* clear wmanIfBsQoSMinReservedRate */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSMinReservedRate.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSMinReservedRate commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSMinReservedRate
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSMINRESERVEDRATE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSTOLERATEDJITTER_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSTOLERATEDJITTER_FLAG;  /* clear wmanIfBsQoSToleratedJitter */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSToleratedJitter.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSToleratedJitter commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSToleratedJitter
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSTOLERATEDJITTER_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSMAXLATENCY_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSMAXLATENCY_FLAG;       /* clear wmanIfBsQoSMaxLatency */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSMaxLatency.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSMaxLatency commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSMaxLatency
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSMAXLATENCY_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSFIXEDVSVARIABLESDUIND_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSFIXEDVSVARIABLESDUIND_FLAG;    /* clear wmanIfBsQoSFixedVsVariableSduInd */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSFixedVsVariableSduInd.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSFixedVsVariableSduInd commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSFixedVsVariableSduInd
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSFIXEDVSVARIABLESDUIND_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSDUSIZE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSDUSIZE_FLAG;  /* clear wmanIfBsQoSSduSize */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSSduSize.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSSduSize commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSSduSize
             */
            rowreq_ctx->column_set_flags |= COLUMN_WMANIFBSQOSSDUSIZE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCSCHEDULINGTYPE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCSCHEDULINGTYPE_FLAG; /* clear wmanIfBsQosScSchedulingType */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScSchedulingType.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScSchedulingType commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScSchedulingType
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCSCHEDULINGTYPE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQENABLE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQENABLE_FLAG;      /* clear wmanIfBsQosScArqEnable */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqEnable.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqEnable commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqEnable
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQENABLE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQWINDOWSIZE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQWINDOWSIZE_FLAG;  /* clear wmanIfBsQosScArqWindowSize */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqWindowSize.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqWindowSize commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqWindowSize
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQWINDOWSIZE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQBLOCKLIFETIME_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQBLOCKLIFETIME_FLAG;       /* clear wmanIfBsQosScArqBlockLifetime */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqBlockLifetime.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqBlockLifetime commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqBlockLifetime
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQBLOCKLIFETIME_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQSYNCLOSSTIMEOUT_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQSYNCLOSSTIMEOUT_FLAG;     /* clear wmanIfBsQosScArqSyncLossTimeout */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqSyncLossTimeout.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqSyncLossTimeout commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqSyncLossTimeout
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQSYNCLOSSTIMEOUT_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQDELIVERINORDER_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQDELIVERINORDER_FLAG;      /* clear wmanIfBsQosScArqDeliverInOrder */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqDeliverInOrder.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqDeliverInOrder commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqDeliverInOrder
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQDELIVERINORDER_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQRXPURGETIMEOUT_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQRXPURGETIMEOUT_FLAG;      /* clear wmanIfBsQosScArqRxPurgeTimeout */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqRxPurgeTimeout.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqRxPurgeTimeout commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqRxPurgeTimeout
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQRXPURGETIMEOUT_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCARQBLOCKSIZE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCARQBLOCKSIZE_FLAG;   /* clear wmanIfBsQosScArqBlockSize */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosScArqBlockSize.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosScArqBlockSize commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosScArqBlockSize
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCARQBLOCKSIZE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSCMINRSVDTOLERABLERATE_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSCMINRSVDTOLERABLERATE_FLAG;   /* clear wmanIfBsQosSCMinRsvdTolerableRate */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQosSCMinRsvdTolerableRate.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQosSCMinRsvdTolerableRate commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQosSCMinRsvdTolerableRate
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSCMINRSVDTOLERABLERATE_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSREQTXPOLICY_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSREQTXPOLICY_FLAG;      /* clear wmanIfBsQoSReqTxPolicy */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSReqTxPolicy.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSReqTxPolicy commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSReqTxPolicy
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSREQTXPOLICY_FLAG;
        }
    }

    if (save_flags & COLUMN_WMANIFBSQOSSERVICECLASSROWSTATUS_FLAG) {
        save_flags &= ~COLUMN_WMANIFBSQOSSERVICECLASSROWSTATUS_FLAG;    /* clear wmanIfBsQoSServiceClassRowStatus */
        /*
         * TODO:482:o: |-> commit column wmanIfBsQoSServiceClassRowStatus.
         */
        rc = -1;
        if (-1 == rc) {
            snmp_log(LOG_ERR,
                     "wmanIfBsServiceClassTable column wmanIfBsQoSServiceClassRowStatus commit failed\n");
        } else {
            /*
             * set flag, in case we need to undo wmanIfBsQoSServiceClassRowStatus
             */
            rowreq_ctx->column_set_flags |=
                COLUMN_WMANIFBSQOSSERVICECLASSROWSTATUS_FLAG;
        }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
        snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n",
                 save_flags);
        return MFD_ERROR;
    }

    return rc;
}                               /* wmanIfBsServiceClassTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * wmanIfBsServiceClassTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param wmanIfBsServiceClassTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
wmanIfBsServiceClassTable_undo_commit(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsServiceClassTable_undo_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:485:M: |-> Undo wmanIfBsServiceClassTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */


    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
}                               /* wmanIfBsServiceClassTable_undo_commit */

/*
 * TODO:440:M: Implement wmanIfBsServiceClassTable node value checks.
 * TODO:450:M: Implement wmanIfBsServiceClassTable undo functions.
 * TODO:460:M: Implement wmanIfBsServiceClassTable set functions.
 * TODO:480:M: Implement wmanIfBsServiceClassTable commit functions.
 */
/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosServiceClassName
 * wmanIfBsQosServiceClassName is subid 2 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.2
 * Description:
Refers to the Service Class Name
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  2 - 128;
 *
 * Its syntax is WmanIfServClassName (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 128)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosServiceClassName_val_ptr
 *        A char containing the new value.
 * @param wmanIfBsQosServiceClassName_val_ptr_len
 *        The size (in bytes) of the data pointed to by wmanIfBsQosServiceClassName_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.wmanIfBsQosServiceClassName).
 *    The length is in (one of) the range set(s):  2 - 128
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosServiceClassName_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     char *wmanIfBsQosServiceClassName_val_ptr,
     size_t wmanIfBsQosServiceClassName_val_ptr_len)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosServiceClassName_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wmanIfBsQosServiceClassName_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosServiceClassName value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosServiceClassName value not illegal */
}                               /* wmanIfBsQosServiceClassName_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosServiceClassName_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosServiceClassName_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosServiceClassName undo.
     */
    /*
     * copy wmanIfBsQosServiceClassName and wmanIfBsQosServiceClassName_len data
     * set rowreq_ctx->undo->wmanIfBsQosServiceClassName from rowreq_ctx->data.wmanIfBsQosServiceClassName
     */
    memcpy(rowreq_ctx->undo->wmanIfBsQosServiceClassName,
           rowreq_ctx->data.wmanIfBsQosServiceClassName,
           (rowreq_ctx->data.wmanIfBsQosServiceClassName_len *
            sizeof(rowreq_ctx->undo->wmanIfBsQosServiceClassName[0])));
    rowreq_ctx->undo->wmanIfBsQosServiceClassName_len =
        rowreq_ctx->data.wmanIfBsQosServiceClassName_len;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosServiceClassName_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosServiceClassName_val_ptr
 *        A char containing the new value.
 * @param wmanIfBsQosServiceClassName_val_ptr_len
 *        The size (in bytes) of the data pointed to by wmanIfBsQosServiceClassName_val_ptr
 */
int
wmanIfBsQosServiceClassName_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                char *wmanIfBsQosServiceClassName_val_ptr,
                                size_t
                                wmanIfBsQosServiceClassName_val_ptr_len)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosServiceClassName_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wmanIfBsQosServiceClassName_val_ptr);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosServiceClassName value.
     * set wmanIfBsQosServiceClassName value in rowreq_ctx->data
     */
    memcpy(rowreq_ctx->data.wmanIfBsQosServiceClassName,
           wmanIfBsQosServiceClassName_val_ptr,
           wmanIfBsQosServiceClassName_val_ptr_len);
    /** convert bytes to number of char */
    rowreq_ctx->data.wmanIfBsQosServiceClassName_len =
        wmanIfBsQosServiceClassName_val_ptr_len /
        sizeof(wmanIfBsQosServiceClassName_val_ptr[0]);

    return MFD_SUCCESS;
}                               /* wmanIfBsQosServiceClassName_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosServiceClassName_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                 rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosServiceClassName_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosServiceClassName undo.
     */
    /*
     * copy wmanIfBsQosServiceClassName and wmanIfBsQosServiceClassName_len data
     * set rowreq_ctx->data.wmanIfBsQosServiceClassName from rowreq_ctx->undo->wmanIfBsQosServiceClassName
     */
    memcpy(rowreq_ctx->data.wmanIfBsQosServiceClassName,
           rowreq_ctx->undo->wmanIfBsQosServiceClassName,
           (rowreq_ctx->undo->wmanIfBsQosServiceClassName_len *
            sizeof(rowreq_ctx->data.wmanIfBsQosServiceClassName[0])));
    rowreq_ctx->data.wmanIfBsQosServiceClassName_len =
        rowreq_ctx->undo->wmanIfBsQosServiceClassName_len;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosServiceClassName_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSTrafficPriority
 * wmanIfBsQoSTrafficPriority is subid 3 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.3
 * Description:
The value of this parameter specifies the priority
             assigned to a service flow. For uplink service flows,
             the BS should use this parameter when determining
             precedence in request service and grant generation,
             and the SS shall preferentially select contention
             Request opportunities for Priority Request CIDs
             based on this priority. Higher numbers indicate higher
             priority
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 7;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSTrafficPriority_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 7
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSTrafficPriority_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx,
                                       long wmanIfBsQoSTrafficPriority_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSTrafficPriority_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSTrafficPriority value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSTrafficPriority value not illegal */
}                               /* wmanIfBsQoSTrafficPriority_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSTrafficPriority_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSTrafficPriority_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSTrafficPriority undo.
     */
    /*
     * copy wmanIfBsQoSTrafficPriority data
     * set rowreq_ctx->undo->wmanIfBsQoSTrafficPriority from rowreq_ctx->data.wmanIfBsQoSTrafficPriority
     */
    rowreq_ctx->undo->wmanIfBsQoSTrafficPriority =
        rowreq_ctx->data.wmanIfBsQoSTrafficPriority;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSTrafficPriority_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSTrafficPriority_val
 *        A long containing the new value.
 */
int
wmanIfBsQoSTrafficPriority_set(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               long wmanIfBsQoSTrafficPriority_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSTrafficPriority_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSTrafficPriority value.
     * set wmanIfBsQoSTrafficPriority value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSTrafficPriority =
        wmanIfBsQoSTrafficPriority_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSTrafficPriority_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSTrafficPriority_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSTrafficPriority_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSTrafficPriority undo.
     */
    /*
     * copy wmanIfBsQoSTrafficPriority data
     * set rowreq_ctx->data.wmanIfBsQoSTrafficPriority from rowreq_ctx->undo->wmanIfBsQoSTrafficPriority
     */
    rowreq_ctx->data.wmanIfBsQoSTrafficPriority =
        rowreq_ctx->undo->wmanIfBsQoSTrafficPriority;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSTrafficPriority_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxSustainedRate
 * wmanIfBsQoSMaxSustainedRate is subid 4 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.4
 * Description:
This parameter defines the peak information rate
             of the service. The rate is expressed in bits per
             second and pertains to the SDUs at the input to
             the system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxSustainedRate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSMaxSustainedRate_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQoSMaxSustainedRate_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxSustainedRate_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSMaxSustainedRate value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSMaxSustainedRate value not illegal */
}                               /* wmanIfBsQoSMaxSustainedRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSMaxSustainedRate_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxSustainedRate_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSMaxSustainedRate undo.
     */
    /*
     * copy wmanIfBsQoSMaxSustainedRate data
     * set rowreq_ctx->undo->wmanIfBsQoSMaxSustainedRate from rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate
     */
    rowreq_ctx->undo->wmanIfBsQoSMaxSustainedRate =
        rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxSustainedRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSMaxSustainedRate_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSMaxSustainedRate_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long wmanIfBsQoSMaxSustainedRate_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxSustainedRate_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSMaxSustainedRate value.
     * set wmanIfBsQoSMaxSustainedRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate =
        wmanIfBsQoSMaxSustainedRate_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxSustainedRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSMaxSustainedRate_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                 rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxSustainedRate_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSMaxSustainedRate undo.
     */
    /*
     * copy wmanIfBsQoSMaxSustainedRate data
     * set rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate from rowreq_ctx->undo->wmanIfBsQoSMaxSustainedRate
     */
    rowreq_ctx->data.wmanIfBsQoSMaxSustainedRate =
        rowreq_ctx->undo->wmanIfBsQoSMaxSustainedRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxSustainedRate_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxTrafficBurst
 * wmanIfBsQoSMaxTrafficBurst is subid 5 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.5
 * Description:
This parameter defines the maximum burst size that
             must be accommodated for the service.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxTrafficBurst_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSMaxTrafficBurst_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx,
                                       u_long
                                       wmanIfBsQoSMaxTrafficBurst_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxTrafficBurst_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSMaxTrafficBurst value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSMaxTrafficBurst value not illegal */
}                               /* wmanIfBsQoSMaxTrafficBurst_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSMaxTrafficBurst_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxTrafficBurst_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSMaxTrafficBurst undo.
     */
    /*
     * copy wmanIfBsQoSMaxTrafficBurst data
     * set rowreq_ctx->undo->wmanIfBsQoSMaxTrafficBurst from rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst
     */
    rowreq_ctx->undo->wmanIfBsQoSMaxTrafficBurst =
        rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxTrafficBurst_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSMaxTrafficBurst_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSMaxTrafficBurst_set(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long wmanIfBsQoSMaxTrafficBurst_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxTrafficBurst_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSMaxTrafficBurst value.
     * set wmanIfBsQoSMaxTrafficBurst value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst =
        wmanIfBsQoSMaxTrafficBurst_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxTrafficBurst_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSMaxTrafficBurst_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxTrafficBurst_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSMaxTrafficBurst undo.
     */
    /*
     * copy wmanIfBsQoSMaxTrafficBurst data
     * set rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst from rowreq_ctx->undo->wmanIfBsQoSMaxTrafficBurst
     */
    rowreq_ctx->data.wmanIfBsQoSMaxTrafficBurst =
        rowreq_ctx->undo->wmanIfBsQoSMaxTrafficBurst;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxTrafficBurst_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMinReservedRate
 * wmanIfBsQoSMinReservedRate is subid 6 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.6
 * Description:
This parameter specifies the minimum rate reserved
             for this service flow.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMinReservedRate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSMinReservedRate_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx,
                                       u_long
                                       wmanIfBsQoSMinReservedRate_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMinReservedRate_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSMinReservedRate value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSMinReservedRate value not illegal */
}                               /* wmanIfBsQoSMinReservedRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSMinReservedRate_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMinReservedRate_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSMinReservedRate undo.
     */
    /*
     * copy wmanIfBsQoSMinReservedRate data
     * set rowreq_ctx->undo->wmanIfBsQoSMinReservedRate from rowreq_ctx->data.wmanIfBsQoSMinReservedRate
     */
    rowreq_ctx->undo->wmanIfBsQoSMinReservedRate =
        rowreq_ctx->data.wmanIfBsQoSMinReservedRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMinReservedRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSMinReservedRate_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSMinReservedRate_set(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long wmanIfBsQoSMinReservedRate_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMinReservedRate_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSMinReservedRate value.
     * set wmanIfBsQoSMinReservedRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSMinReservedRate =
        wmanIfBsQoSMinReservedRate_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMinReservedRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSMinReservedRate_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMinReservedRate_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSMinReservedRate undo.
     */
    /*
     * copy wmanIfBsQoSMinReservedRate data
     * set rowreq_ctx->data.wmanIfBsQoSMinReservedRate from rowreq_ctx->undo->wmanIfBsQoSMinReservedRate
     */
    rowreq_ctx->data.wmanIfBsQoSMinReservedRate =
        rowreq_ctx->undo->wmanIfBsQoSMinReservedRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMinReservedRate_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSToleratedJitter
 * wmanIfBsQoSToleratedJitter is subid 7 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.7
 * Description:
This parameter defines the Maximum delay 
             variation (jitter) for the connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSToleratedJitter_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSToleratedJitter_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx,
                                       u_long
                                       wmanIfBsQoSToleratedJitter_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSToleratedJitter_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSToleratedJitter value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSToleratedJitter value not illegal */
}                               /* wmanIfBsQoSToleratedJitter_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSToleratedJitter_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSToleratedJitter_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSToleratedJitter undo.
     */
    /*
     * copy wmanIfBsQoSToleratedJitter data
     * set rowreq_ctx->undo->wmanIfBsQoSToleratedJitter from rowreq_ctx->data.wmanIfBsQoSToleratedJitter
     */
    rowreq_ctx->undo->wmanIfBsQoSToleratedJitter =
        rowreq_ctx->data.wmanIfBsQoSToleratedJitter;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSToleratedJitter_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSToleratedJitter_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSToleratedJitter_set(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               u_long wmanIfBsQoSToleratedJitter_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSToleratedJitter_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSToleratedJitter value.
     * set wmanIfBsQoSToleratedJitter value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSToleratedJitter =
        wmanIfBsQoSToleratedJitter_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSToleratedJitter_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSToleratedJitter_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSToleratedJitter_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSToleratedJitter undo.
     */
    /*
     * copy wmanIfBsQoSToleratedJitter data
     * set rowreq_ctx->data.wmanIfBsQoSToleratedJitter from rowreq_ctx->undo->wmanIfBsQoSToleratedJitter
     */
    rowreq_ctx->data.wmanIfBsQoSToleratedJitter =
        rowreq_ctx->undo->wmanIfBsQoSToleratedJitter;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSToleratedJitter_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSMaxLatency
 * wmanIfBsQoSMaxLatency is subid 8 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.8
 * Description:
The value of this parameter specifies the maximum
             latency between the reception of a packet by the BS
             or SS on its network interface and the forwarding
             of the packet to its RF Interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSMaxLatency_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSMaxLatency_check_value(wmanIfBsServiceClassTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long wmanIfBsQoSMaxLatency_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxLatency_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSMaxLatency value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSMaxLatency value not illegal */
}                               /* wmanIfBsQoSMaxLatency_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSMaxLatency_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                                 rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxLatency_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSMaxLatency undo.
     */
    /*
     * copy wmanIfBsQoSMaxLatency data
     * set rowreq_ctx->undo->wmanIfBsQoSMaxLatency from rowreq_ctx->data.wmanIfBsQoSMaxLatency
     */
    rowreq_ctx->undo->wmanIfBsQoSMaxLatency =
        rowreq_ctx->data.wmanIfBsQoSMaxLatency;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxLatency_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSMaxLatency_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSMaxLatency_set(wmanIfBsServiceClassTable_rowreq_ctx *
                          rowreq_ctx, u_long wmanIfBsQoSMaxLatency_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxLatency_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSMaxLatency value.
     * set wmanIfBsQoSMaxLatency value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSMaxLatency = wmanIfBsQoSMaxLatency_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxLatency_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSMaxLatency_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                           rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSMaxLatency_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSMaxLatency undo.
     */
    /*
     * copy wmanIfBsQoSMaxLatency data
     * set rowreq_ctx->data.wmanIfBsQoSMaxLatency from rowreq_ctx->undo->wmanIfBsQoSMaxLatency
     */
    rowreq_ctx->data.wmanIfBsQoSMaxLatency =
        rowreq_ctx->undo->wmanIfBsQoSMaxLatency;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSMaxLatency_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSFixedVsVariableSduInd
 * wmanIfBsQoSFixedVsVariableSduInd is subid 9 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.9
 * Description:
The value of this parameter specifies whether the SDUs
             on the service flow are variable-length (0) or 
             fixed-length (1). The parameter is used only if
             packing is on for the service flow. The default value
             is 0, i.e.,variable-length SDUs.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: variableLength
 *
 * Enum range: 2/8. Values:  variableLength(0), fixedLength(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSFixedVsVariableSduInd_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  variableLength(0), fixedLength(1)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSFixedVsVariableSduInd_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQoSFixedVsVariableSduInd_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSFixedVsVariableSduInd_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSFixedVsVariableSduInd value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSFixedVsVariableSduInd value not illegal */
}                               /* wmanIfBsQoSFixedVsVariableSduInd_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSFixedVsVariableSduInd_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSFixedVsVariableSduInd_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSFixedVsVariableSduInd undo.
     */
    /*
     * copy wmanIfBsQoSFixedVsVariableSduInd data
     * set rowreq_ctx->undo->wmanIfBsQoSFixedVsVariableSduInd from rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd
     */
    rowreq_ctx->undo->wmanIfBsQoSFixedVsVariableSduInd =
        rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSFixedVsVariableSduInd_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSFixedVsVariableSduInd_val
 *        A long containing the new value.
 */
int
wmanIfBsQoSFixedVsVariableSduInd_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long
                                     wmanIfBsQoSFixedVsVariableSduInd_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSFixedVsVariableSduInd_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSFixedVsVariableSduInd value.
     * set wmanIfBsQoSFixedVsVariableSduInd value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd =
        wmanIfBsQoSFixedVsVariableSduInd_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSFixedVsVariableSduInd_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSFixedVsVariableSduInd_undo(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSFixedVsVariableSduInd_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSFixedVsVariableSduInd undo.
     */
    /*
     * copy wmanIfBsQoSFixedVsVariableSduInd data
     * set rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd from rowreq_ctx->undo->wmanIfBsQoSFixedVsVariableSduInd
     */
    rowreq_ctx->data.wmanIfBsQoSFixedVsVariableSduInd =
        rowreq_ctx->undo->wmanIfBsQoSFixedVsVariableSduInd;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSFixedVsVariableSduInd_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSSduSize
 * wmanIfBsQoSSduSize is subid 10 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.10
 * Description:
The value of this parameter specifies the length of the
             SDU for a fixed-length SDU service flow. This parameter
             is used only if packing is on and the service flow is
             indicated as carrying fixed-length SDUs. The default
             value is 49 bytes, i.e., VC-switched ATM cells with PHS.
             The parameter is relevant for both ATM and Packet
             Convergence Sublayers.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 49
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSSduSize_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSSduSize_check_value(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx, u_long wmanIfBsQoSSduSize_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSSduSize_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSSduSize value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSSduSize value not illegal */
}                               /* wmanIfBsQoSSduSize_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSSduSize_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                              rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSSduSize_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSSduSize undo.
     */
    /*
     * copy wmanIfBsQoSSduSize data
     * set rowreq_ctx->undo->wmanIfBsQoSSduSize from rowreq_ctx->data.wmanIfBsQoSSduSize
     */
    rowreq_ctx->undo->wmanIfBsQoSSduSize =
        rowreq_ctx->data.wmanIfBsQoSSduSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSSduSize_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSSduSize_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQoSSduSize_set(wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
                       u_long wmanIfBsQoSSduSize_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSSduSize_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSSduSize value.
     * set wmanIfBsQoSSduSize value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSSduSize = wmanIfBsQoSSduSize_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSSduSize_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSSduSize_undo(wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSSduSize_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSSduSize undo.
     */
    /*
     * copy wmanIfBsQoSSduSize data
     * set rowreq_ctx->data.wmanIfBsQoSSduSize from rowreq_ctx->undo->wmanIfBsQoSSduSize
     */
    rowreq_ctx->data.wmanIfBsQoSSduSize =
        rowreq_ctx->undo->wmanIfBsQoSSduSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSSduSize_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScSchedulingType
 * wmanIfBsQosScSchedulingType is subid 11 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.11
 * Description:
Specifies the upstream scheduling service used for
             upstream service flow. If the referenced parameter
             is not present in the corresponding 802.16 QOS
             Parameter Set of an upstream service flow, the
             default value of this object is bestEffort(2).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: bestEffort
 *
 * Enum range: 3/8. Values:  undefined(1), bestEffort(2), nonRealTimePollingService(3), realTimePollingService(4), reserved(5), unsolicitedGrantService(6)
 *
 * Its syntax is WmanIfSfSchedulingType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScSchedulingType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  undefined(1), bestEffort(2), nonRealTimePollingService(3), realTimePollingService(4), reserved(5), unsolicitedGrantService(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScSchedulingType_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQosScSchedulingType_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScSchedulingType_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScSchedulingType value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScSchedulingType value not illegal */
}                               /* wmanIfBsQosScSchedulingType_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScSchedulingType_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScSchedulingType_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScSchedulingType undo.
     */
    /*
     * copy wmanIfBsQosScSchedulingType data
     * set rowreq_ctx->undo->wmanIfBsQosScSchedulingType from rowreq_ctx->data.wmanIfBsQosScSchedulingType
     */
    rowreq_ctx->undo->wmanIfBsQosScSchedulingType =
        rowreq_ctx->data.wmanIfBsQosScSchedulingType;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScSchedulingType_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScSchedulingType_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScSchedulingType_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx,
                                u_long wmanIfBsQosScSchedulingType_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScSchedulingType_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScSchedulingType value.
     * set wmanIfBsQosScSchedulingType value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScSchedulingType =
        wmanIfBsQosScSchedulingType_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScSchedulingType_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScSchedulingType_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                 rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScSchedulingType_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScSchedulingType undo.
     */
    /*
     * copy wmanIfBsQosScSchedulingType data
     * set rowreq_ctx->data.wmanIfBsQosScSchedulingType from rowreq_ctx->undo->wmanIfBsQosScSchedulingType
     */
    rowreq_ctx->data.wmanIfBsQosScSchedulingType =
        rowreq_ctx->undo->wmanIfBsQosScSchedulingType;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScSchedulingType_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqEnable
 * wmanIfBsQosScArqEnable is subid 12 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.12
 * Description:
True(1) ARQ enabling is requested for the connection.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqEnable_check_value(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long wmanIfBsQosScArqEnable_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqEnable_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqEnable value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqEnable value not illegal */
}                               /* wmanIfBsQosScArqEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqEnable_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                                  rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqEnable_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqEnable undo.
     */
    /*
     * copy wmanIfBsQosScArqEnable data
     * set rowreq_ctx->undo->wmanIfBsQosScArqEnable from rowreq_ctx->data.wmanIfBsQosScArqEnable
     */
    rowreq_ctx->undo->wmanIfBsQosScArqEnable =
        rowreq_ctx->data.wmanIfBsQosScArqEnable;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqEnable_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqEnable_set(wmanIfBsServiceClassTable_rowreq_ctx *
                           rowreq_ctx, u_long wmanIfBsQosScArqEnable_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqEnable_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqEnable value.
     * set wmanIfBsQosScArqEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqEnable = wmanIfBsQosScArqEnable_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqEnable_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                            rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqEnable_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqEnable undo.
     */
    /*
     * copy wmanIfBsQosScArqEnable data
     * set rowreq_ctx->data.wmanIfBsQosScArqEnable from rowreq_ctx->undo->wmanIfBsQosScArqEnable
     */
    rowreq_ctx->data.wmanIfBsQosScArqEnable =
        rowreq_ctx->undo->wmanIfBsQosScArqEnable;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqEnable_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqWindowSize
 * wmanIfBsQosScArqWindowSize is subid 13 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.13
 * Description:
Indicates the maximum number of unacknowledged 
             fragments at any time.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 1024;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqWindowSize_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 1024
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqWindowSize_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx,
                                       long wmanIfBsQosScArqWindowSize_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqWindowSize_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqWindowSize value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqWindowSize value not illegal */
}                               /* wmanIfBsQosScArqWindowSize_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqWindowSize_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqWindowSize_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqWindowSize undo.
     */
    /*
     * copy wmanIfBsQosScArqWindowSize data
     * set rowreq_ctx->undo->wmanIfBsQosScArqWindowSize from rowreq_ctx->data.wmanIfBsQosScArqWindowSize
     */
    rowreq_ctx->undo->wmanIfBsQosScArqWindowSize =
        rowreq_ctx->data.wmanIfBsQosScArqWindowSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqWindowSize_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqWindowSize_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqWindowSize_set(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx,
                               long wmanIfBsQosScArqWindowSize_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqWindowSize_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqWindowSize value.
     * set wmanIfBsQosScArqWindowSize value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqWindowSize =
        wmanIfBsQosScArqWindowSize_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqWindowSize_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqWindowSize_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqWindowSize_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqWindowSize undo.
     */
    /*
     * copy wmanIfBsQosScArqWindowSize data
     * set rowreq_ctx->data.wmanIfBsQosScArqWindowSize from rowreq_ctx->undo->wmanIfBsQosScArqWindowSize
     */
    rowreq_ctx->data.wmanIfBsQosScArqWindowSize =
        rowreq_ctx->undo->wmanIfBsQosScArqWindowSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqWindowSize_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqBlockLifetime
 * wmanIfBsQosScArqBlockLifetime is subid 14 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.14
 * Description:
The maximum time interval an ARQ fragment will be
             managed by the transmitter ARQ machine, once
             initial transmission of the fragment has occured.
             If transmission or retransmission of the fragment
             is not acknowledged by the receiver before the 
             time limit is reached, the fragment is discarded.
             A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqBlockLifetime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqBlockLifetime_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     long wmanIfBsQosScArqBlockLifetime_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockLifetime_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqBlockLifetime value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqBlockLifetime value not illegal */
}                               /* wmanIfBsQosScArqBlockLifetime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqBlockLifetime_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockLifetime_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqBlockLifetime undo.
     */
    /*
     * copy wmanIfBsQosScArqBlockLifetime data
     * set rowreq_ctx->undo->wmanIfBsQosScArqBlockLifetime from rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime
     */
    rowreq_ctx->undo->wmanIfBsQosScArqBlockLifetime =
        rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockLifetime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqBlockLifetime_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqBlockLifetime_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                  rowreq_ctx,
                                  long wmanIfBsQosScArqBlockLifetime_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockLifetime_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqBlockLifetime value.
     * set wmanIfBsQosScArqBlockLifetime value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime =
        wmanIfBsQosScArqBlockLifetime_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockLifetime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqBlockLifetime_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockLifetime_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqBlockLifetime undo.
     */
    /*
     * copy wmanIfBsQosScArqBlockLifetime data
     * set rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime from rowreq_ctx->undo->wmanIfBsQosScArqBlockLifetime
     */
    rowreq_ctx->data.wmanIfBsQosScArqBlockLifetime =
        rowreq_ctx->undo->wmanIfBsQosScArqBlockLifetime;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockLifetime_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqSyncLossTimeout
 * wmanIfBsQosScArqSyncLossTimeout is subid 15 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.15
 * Description:
The maximum interval before declaring a loss
             of synchronization of the sender and receiver
             state machines. A value of 0 means Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqSyncLossTimeout_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqSyncLossTimeout_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     long wmanIfBsQosScArqSyncLossTimeout_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqSyncLossTimeout_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqSyncLossTimeout value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqSyncLossTimeout value not illegal */
}                               /* wmanIfBsQosScArqSyncLossTimeout_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqSyncLossTimeout_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqSyncLossTimeout_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqSyncLossTimeout undo.
     */
    /*
     * copy wmanIfBsQosScArqSyncLossTimeout data
     * set rowreq_ctx->undo->wmanIfBsQosScArqSyncLossTimeout from rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout
     */
    rowreq_ctx->undo->wmanIfBsQosScArqSyncLossTimeout =
        rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqSyncLossTimeout_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqSyncLossTimeout_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqSyncLossTimeout_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                    rowreq_ctx,
                                    long
                                    wmanIfBsQosScArqSyncLossTimeout_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqSyncLossTimeout_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqSyncLossTimeout value.
     * set wmanIfBsQosScArqSyncLossTimeout value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout =
        wmanIfBsQosScArqSyncLossTimeout_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqSyncLossTimeout_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqSyncLossTimeout_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqSyncLossTimeout_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqSyncLossTimeout undo.
     */
    /*
     * copy wmanIfBsQosScArqSyncLossTimeout data
     * set rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout from rowreq_ctx->undo->wmanIfBsQosScArqSyncLossTimeout
     */
    rowreq_ctx->data.wmanIfBsQosScArqSyncLossTimeout =
        rowreq_ctx->undo->wmanIfBsQosScArqSyncLossTimeout;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqSyncLossTimeout_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqDeliverInOrder
 * wmanIfBsQosScArqDeliverInOrder is subid 16 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.16
 * Description:
Indicates whether or not data is to be delivered
             by the receiving MAC to its client application
             in the order in which data was handed off to the
             originating MAC.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqDeliverInOrder_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqDeliverInOrder_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQosScArqDeliverInOrder_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqDeliverInOrder_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqDeliverInOrder value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqDeliverInOrder value not illegal */
}                               /* wmanIfBsQosScArqDeliverInOrder_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqDeliverInOrder_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqDeliverInOrder_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqDeliverInOrder undo.
     */
    /*
     * copy wmanIfBsQosScArqDeliverInOrder data
     * set rowreq_ctx->undo->wmanIfBsQosScArqDeliverInOrder from rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder
     */
    rowreq_ctx->undo->wmanIfBsQosScArqDeliverInOrder =
        rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqDeliverInOrder_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqDeliverInOrder_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqDeliverInOrder_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long
                                   wmanIfBsQosScArqDeliverInOrder_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqDeliverInOrder_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqDeliverInOrder value.
     * set wmanIfBsQosScArqDeliverInOrder value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder =
        wmanIfBsQosScArqDeliverInOrder_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqDeliverInOrder_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqDeliverInOrder_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                    rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqDeliverInOrder_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqDeliverInOrder undo.
     */
    /*
     * copy wmanIfBsQosScArqDeliverInOrder data
     * set rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder from rowreq_ctx->undo->wmanIfBsQosScArqDeliverInOrder
     */
    rowreq_ctx->data.wmanIfBsQosScArqDeliverInOrder =
        rowreq_ctx->undo->wmanIfBsQosScArqDeliverInOrder;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqDeliverInOrder_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqRxPurgeTimeout
 * wmanIfBsQosScArqRxPurgeTimeout is subid 17 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.17
 * Description:
Indicates the time interval the ARQ window is advanced
             after a fragment is received. A value of 0 means
             Infinite.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqRxPurgeTimeout_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqRxPurgeTimeout_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     long wmanIfBsQosScArqRxPurgeTimeout_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqRxPurgeTimeout_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqRxPurgeTimeout value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqRxPurgeTimeout value not illegal */
}                               /* wmanIfBsQosScArqRxPurgeTimeout_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqRxPurgeTimeout_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqRxPurgeTimeout_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqRxPurgeTimeout undo.
     */
    /*
     * copy wmanIfBsQosScArqRxPurgeTimeout data
     * set rowreq_ctx->undo->wmanIfBsQosScArqRxPurgeTimeout from rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout
     */
    rowreq_ctx->undo->wmanIfBsQosScArqRxPurgeTimeout =
        rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqRxPurgeTimeout_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqRxPurgeTimeout_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqRxPurgeTimeout_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   long wmanIfBsQosScArqRxPurgeTimeout_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqRxPurgeTimeout_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqRxPurgeTimeout value.
     * set wmanIfBsQosScArqRxPurgeTimeout value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout =
        wmanIfBsQosScArqRxPurgeTimeout_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqRxPurgeTimeout_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqRxPurgeTimeout_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                                    rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqRxPurgeTimeout_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqRxPurgeTimeout undo.
     */
    /*
     * copy wmanIfBsQosScArqRxPurgeTimeout data
     * set rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout from rowreq_ctx->undo->wmanIfBsQosScArqRxPurgeTimeout
     */
    rowreq_ctx->data.wmanIfBsQosScArqRxPurgeTimeout =
        rowreq_ctx->undo->wmanIfBsQosScArqRxPurgeTimeout;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqRxPurgeTimeout_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosScArqBlockSize
 * wmanIfBsQosScArqBlockSize is subid 18 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.18
 * Description:
The value of this parameter specifies the size of an
             ARQ block. This parameter shall be established by
             negotiation during the connection creation dialog.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 2040;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosScArqBlockSize_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 2040
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosScArqBlockSize_check_value(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx,
                                      long wmanIfBsQosScArqBlockSize_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockSize_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosScArqBlockSize value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosScArqBlockSize value not illegal */
}                               /* wmanIfBsQosScArqBlockSize_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosScArqBlockSize_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockSize_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosScArqBlockSize undo.
     */
    /*
     * copy wmanIfBsQosScArqBlockSize data
     * set rowreq_ctx->undo->wmanIfBsQosScArqBlockSize from rowreq_ctx->data.wmanIfBsQosScArqBlockSize
     */
    rowreq_ctx->undo->wmanIfBsQosScArqBlockSize =
        rowreq_ctx->data.wmanIfBsQosScArqBlockSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockSize_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosScArqBlockSize_val
 *        A long containing the new value.
 */
int
wmanIfBsQosScArqBlockSize_set(wmanIfBsServiceClassTable_rowreq_ctx *
                              rowreq_ctx,
                              long wmanIfBsQosScArqBlockSize_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockSize_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosScArqBlockSize value.
     * set wmanIfBsQosScArqBlockSize value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosScArqBlockSize =
        wmanIfBsQosScArqBlockSize_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockSize_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosScArqBlockSize_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                               rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosScArqBlockSize_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosScArqBlockSize undo.
     */
    /*
     * copy wmanIfBsQosScArqBlockSize data
     * set rowreq_ctx->data.wmanIfBsQosScArqBlockSize from rowreq_ctx->undo->wmanIfBsQosScArqBlockSize
     */
    rowreq_ctx->data.wmanIfBsQosScArqBlockSize =
        rowreq_ctx->undo->wmanIfBsQosScArqBlockSize;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosScArqBlockSize_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQosSCMinRsvdTolerableRate
 * wmanIfBsQosSCMinRsvdTolerableRate is subid 19 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.19
 * Description:
Minimum Tolerable Traffic Rate = R (bits/sec) with
             time base T(sec) means the following. Let S denote
             additional demand accumulated at the MAC SAP of the
             transmitter during an arbitrary time interval of the
             length T. Then the amount of data forwarded at the
             receiver to CS (in bits) during this interval should
             be not less than min {S, R * T}.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQosSCMinRsvdTolerableRate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQosSCMinRsvdTolerableRate_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQosSCMinRsvdTolerableRate_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosSCMinRsvdTolerableRate_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQosSCMinRsvdTolerableRate value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQosSCMinRsvdTolerableRate value not illegal */
}                               /* wmanIfBsQosSCMinRsvdTolerableRate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQosSCMinRsvdTolerableRate_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosSCMinRsvdTolerableRate_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQosSCMinRsvdTolerableRate undo.
     */
    /*
     * copy wmanIfBsQosSCMinRsvdTolerableRate data
     * set rowreq_ctx->undo->wmanIfBsQosSCMinRsvdTolerableRate from rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate
     */
    rowreq_ctx->undo->wmanIfBsQosSCMinRsvdTolerableRate =
        rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosSCMinRsvdTolerableRate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQosSCMinRsvdTolerableRate_val
 *        A u_long containing the new value.
 */
int
wmanIfBsQosSCMinRsvdTolerableRate_set(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx,
                                      u_long
                                      wmanIfBsQosSCMinRsvdTolerableRate_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosSCMinRsvdTolerableRate_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQosSCMinRsvdTolerableRate value.
     * set wmanIfBsQosSCMinRsvdTolerableRate value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate =
        wmanIfBsQosSCMinRsvdTolerableRate_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQosSCMinRsvdTolerableRate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQosSCMinRsvdTolerableRate_undo(wmanIfBsServiceClassTable_rowreq_ctx
                                       * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQosSCMinRsvdTolerableRate_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQosSCMinRsvdTolerableRate undo.
     */
    /*
     * copy wmanIfBsQosSCMinRsvdTolerableRate data
     * set rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate from rowreq_ctx->undo->wmanIfBsQosSCMinRsvdTolerableRate
     */
    rowreq_ctx->data.wmanIfBsQosSCMinRsvdTolerableRate =
        rowreq_ctx->undo->wmanIfBsQosSCMinRsvdTolerableRate;


    return MFD_SUCCESS;
}                               /* wmanIfBsQosSCMinRsvdTolerableRate_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSReqTxPolicy
 * wmanIfBsQoSReqTxPolicy is subid 20 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.20
 * Description:
The value of this parameter provides the capability to
             specify certain attributes for the associated service
             flow. An attribute is enabled by setting the
             corresponding bit position to 1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 6/16. Values:  noBroadcastBwReq(0), reserved1(1), noPiggybackReq(2), noFragmentData(3), noPHS(4), noSduPacking(5), noCrc(6), reserved2(7)
 *
 * Its syntax is BITS (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSReqTxPolicy_val
 *        A char containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The value is one of  noBroadcastBwReq(0), reserved1(1), noPiggybackReq(2), noFragmentData(3), noPHS(4), noSduPacking(5), noCrc(6), reserved2(7)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSReqTxPolicy_check_value(wmanIfBsServiceClassTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long wmanIfBsQoSReqTxPolicy_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSReqTxPolicy_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSReqTxPolicy value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSReqTxPolicy value not illegal */
}                               /* wmanIfBsQoSReqTxPolicy_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSReqTxPolicy_undo_setup(wmanIfBsServiceClassTable_rowreq_ctx *
                                  rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSReqTxPolicy_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSReqTxPolicy undo.
     */
    /*
     * copy wmanIfBsQoSReqTxPolicy data
     * set rowreq_ctx->undo->wmanIfBsQoSReqTxPolicy from rowreq_ctx->data.wmanIfBsQoSReqTxPolicy
     */
    rowreq_ctx->undo->wmanIfBsQoSReqTxPolicy =
        rowreq_ctx->data.wmanIfBsQoSReqTxPolicy;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSReqTxPolicy_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSReqTxPolicy_val
 *        A char containing the new value.
 */
int
wmanIfBsQoSReqTxPolicy_set(wmanIfBsServiceClassTable_rowreq_ctx *
                           rowreq_ctx, u_long wmanIfBsQoSReqTxPolicy_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSReqTxPolicy_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSReqTxPolicy value.
     * set wmanIfBsQoSReqTxPolicy value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSReqTxPolicy = wmanIfBsQoSReqTxPolicy_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSReqTxPolicy_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSReqTxPolicy_undo(wmanIfBsServiceClassTable_rowreq_ctx *
                            rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSReqTxPolicy_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSReqTxPolicy undo.
     */
    /*
     * copy wmanIfBsQoSReqTxPolicy data
     * set rowreq_ctx->data.wmanIfBsQoSReqTxPolicy from rowreq_ctx->undo->wmanIfBsQoSReqTxPolicy
     */
    rowreq_ctx->data.wmanIfBsQoSReqTxPolicy =
        rowreq_ctx->undo->wmanIfBsQoSReqTxPolicy;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSReqTxPolicy_undo */

/*---------------------------------------------------------------------
 * WMAN-IF-MIB::wmanIfBsServiceClassEntry.wmanIfBsQoSServiceClassRowStatus
 * wmanIfBsQoSServiceClassRowStatus is subid 21 of wmanIfBsServiceClassEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.2.1.10.184.1.1.1.3.1.21
 * Description:
This object is used to create a new row or modify or
             delete an existing row in this table.

             If the implementator of this MIB has choosen not
             to implement 'dynamic assignment' of profiles, this
             object is not useful and should return noSuchName
             upon SNMP request.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wmanIfBsQoSServiceClassRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * wmanIfBsServiceClassTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wmanIfBsQoSServiceClassRowStatus_check_value
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx,
     u_long wmanIfBsQoSServiceClassRowStatus_val)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSServiceClassRowStatus_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wmanIfBsQoSServiceClassRowStatus value.
     */

    return MFD_SUCCESS;         /* wmanIfBsQoSServiceClassRowStatus value not illegal */
}                               /* wmanIfBsQoSServiceClassRowStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (wmanIfBsServiceClassTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * wmanIfBsServiceClassTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wmanIfBsQoSServiceClassRowStatus_undo_setup
    (wmanIfBsServiceClassTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSServiceClassRowStatus_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wmanIfBsQoSServiceClassRowStatus undo.
     */
    /*
     * copy wmanIfBsQoSServiceClassRowStatus data
     * set rowreq_ctx->undo->wmanIfBsQoSServiceClassRowStatus from rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus
     */
    rowreq_ctx->undo->wmanIfBsQoSServiceClassRowStatus =
        rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSServiceClassRowStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wmanIfBsQoSServiceClassRowStatus_val
 *        A long containing the new value.
 */
int
wmanIfBsQoSServiceClassRowStatus_set(wmanIfBsServiceClassTable_rowreq_ctx *
                                     rowreq_ctx,
                                     u_long
                                     wmanIfBsQoSServiceClassRowStatus_val)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSServiceClassRowStatus_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set wmanIfBsQoSServiceClassRowStatus value.
     * set wmanIfBsQoSServiceClassRowStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus =
        wmanIfBsQoSServiceClassRowStatus_val;

    return MFD_SUCCESS;
}                               /* wmanIfBsQoSServiceClassRowStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wmanIfBsQoSServiceClassRowStatus_undo(wmanIfBsServiceClassTable_rowreq_ctx
                                      * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:wmanIfBsServiceClassTable:wmanIfBsQoSServiceClassRowStatus_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wmanIfBsQoSServiceClassRowStatus undo.
     */
    /*
     * copy wmanIfBsQoSServiceClassRowStatus data
     * set rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus from rowreq_ctx->undo->wmanIfBsQoSServiceClassRowStatus
     */
    rowreq_ctx->data.wmanIfBsQoSServiceClassRowStatus =
        rowreq_ctx->undo->wmanIfBsQoSServiceClassRowStatus;


    return MFD_SUCCESS;
}                               /* wmanIfBsQoSServiceClassRowStatus_undo */

/** @} */
